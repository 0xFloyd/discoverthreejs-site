<h1 id="the-document-object-model-and-dom-api">The Document Object Model and DOM API</h1>
<p>Over the last couple of chapters, we&rsquo;ve covered <a href="/book/appendix/html-and-css-reference/">some very basic HTML and CSS</a>, and a whole lot of <a href="/book/appendix/javascript-reference/">slightly less basic JavaScript</a>.</p>
<p>In this chapter, we&rsquo;ll look at how HTML, CSS, and JavaScript interact to create a web page. While doing so, we&rsquo;ll show you how to manipulate your HTML document from within JavaScript.</p>
<h2 id="the-developer-console">The Developer Console</h2>
<p>You can press the <strong>F12</strong> key on most browsers to open the <a href="https://developer.mozilla.org/en-US/docs/Tools/Browser_Console" target="_blank" rel="noopener noreferrer">Developer Console</a>. Try that now, and if it doesn&rsquo;t work then look up the documentation for your browser and find out how to open the console.</p>
<p>Take some time to explore this window now. You&rsquo;ll be using this a <em>lot</em> throughout your career as a three.js developer, or indeed while doing any kind of web development.</p>
<p>There&rsquo;s a lot to see here, but we&rsquo;ll only use two of the tabs in this book: the <em>Elements</em> tab, and the <em>Console</em> tab.</p>
<h3 id="the-elements-tab">The Elements Tab</h3>
<p>The <em>Elements</em> tab shows the structure of your HTML page. Here, you can view and edit HTML elements and the CSS applied to them.</p>
<h3 id="the-console-tab">The Console Tab</h3>
<p>The <em>Console</em> tab displays any messages, warning, or errors generated by the current page, and you can also use this as an interactive JavaScript shell, or <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop" target="_blank" rel="noopener noreferrer">REPL</a>, which is great for testing small pieces of JavaScript code.</p>
<h3 id="log-to-console">Logging to the Console with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/log" target="_blank" rel="noopener noreferrer"><code>console.log</code></a></h3>
<p><code>console.log()</code> allows you to log information to the console. This is the main debugging technique we&rsquo;ll use in this book. It&rsquo;s a simple but powerful technique, and until you start to create more complex apps it&rsquo;s likely to be the only one you need. Whenever you want to check the value of a variable, or details of an object or class, you can simply log them to the console and take a look.</p>
<p>Here&rsquo;s how to check the value of a variable called <code>x</code> using the browser console:</p>


<section class="highlight-wrapper"><span class="caption">Using the console to view the value of a variable</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
let x = &#39;something&#39;;

// You have done some work and  now you expect that x = &#39;something else&#39;.
// But how do you test this? Simple! Use:

console.log(x);

// output: &#34;something else&#34;
</code>
  </pre>
</section>

<p>There are a range of other console methods that we can use, such as <code>console.warn</code>, <code>console.error</code>, <code>console.table</code>, <code>console.time</code>, and so on. You can see them all on the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Console" target="_blank" rel="noopener noreferrer">MDN console page</a>.</p>
<h2 id="the-document-object-model-dom">The Document Object Model (DOM)</h2>
<p>An HTML document is a tree structure, where <a href="/book/appendix/html-and-css-reference/#element">elements</a> like <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>, <code>&lt;div&gt;</code>, <code>&lt;p&gt;</code>, and so on, are leaves of the tree:</p>
<figure >
  <img src="/static/images//appendix/html-tree.svg" loading="lazy" alt="The HTML Tree Structure" title="The HTML Tree Structure"  /></figure>
<p>To work with an HTML page in JavaScript, we need to create a representation of this structure as a JavaScript object, and that&rsquo;s where the Document Object Model comes in.</p>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction" target="_blank" rel="noopener noreferrer">Document Object Model</a> (DOM) is a representation of the HTML document modeled as a JavaScript object.</p>
<p>Using the DOM, we can access and manipulate the elements in an HTML page using JavaScript.</p>
<p>A web page that looks like this:</p>


<section class="highlight-wrapper"><span class="caption">A minimalistic HTML document</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-html match-braces">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Page Title&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;h1&gt;A Heading&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code>
  </pre>
</section>

<p>&hellip;is represented as a series of nested JavaScript objects that looks like this:</p>


<section class="highlight-wrapper"><span class="caption">The DOM: A representation of an HTML document in JavaScript</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
window = {
  document: {
    head: {
      ...
    },

    body: {
      ...
    },
  },
};
</code>
  </pre>
</section>

<p>This is a highly simplified example. There are <em>lots</em> of properties and methods attached to the <code>window</code> and <code>document</code> objects, which we have represented here using <code>...</code>. You can open up the developer console (press F12) on any web page and type <code>window</code> to explore them.</p>
<h2 id="the-dom-api">The DOM API</h2>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API" target="_blank" rel="noopener noreferrer">DOM API</a> is a set of interfaces that we can use in JavaScript to manipulate the DOM. We&rsquo;ll find these interfaces (in plainer words, methods and properties), attached to every level of the DOM.</p>
<p>For example, often we want to set CSS styles on an element using JavaScript. Nearly every element in the DOM has a <code>.style</code> property that we can use for this purpose. Using our simple example above, in JavaScript, we can access the style properties of the head and body like this:</p>


<section class="highlight-wrapper"><span class="caption">Using the DOM API, we can access properties and methods such as style on HTML elements</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
window.document.head.style;

window.document.body.style;
</code>
  </pre>
</section>

<p>We can also access the <code>&lt;h1&gt;</code> element&rsquo;s style, although it takes a little more work, as we&rsquo;ll see below.</p>
<h3 id="global-object">The Browser&rsquo;s Global Object: Window</h3>
<p>In the previous chapter, we explored how the <a href="/book/appendix/javascript-reference/#global-scope">global scope</a> is represented in the browser using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window" target="_blank" rel="noopener noreferrer"><code>window</code></a> object.</p>
<p>As we saw then, we can access <code>window</code> and any properties attached to it from anywhere in our code. The DOM API is attached to <code>window</code> which means we can access that from anywhere too.</p>
<p>The global <code>window</code> object is specific to web browsers. Other JavaScript environments such as Node.js may behave differently.</p>
<h3 id="document">Document</h3>
<p>Another important part of the DOM API is <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document" target="_blank" rel="noopener noreferrer"><code>Document</code></a>. We can access this using <code>window.document</code> (or just <code>document</code> as we&rsquo;ll see in a moment). This represents the actual HTML document of the current page. The rest of the elements on the page are located further down, like <code>document.body</code> and <code>document.head</code>.</p>
<h3 id="you-dont-always-need-to-type-window">You Don&rsquo;t Always Need to Type <code>window</code></h3>
<p>Whenever we use a variable in JavaScript, the engine searches for it in the local scope (say, inside the current function). If it doesn&rsquo;t find it there, it looks in the parent scope (for example, the module scope). The engine keeps searching through scopes for the variable until it reaches the final scope, which is global scope.</p>
<p>This means, to access a property of <code>window</code>, we don&rsquo;t need to type <code>window</code>.</p>
<p>In the second line here, when we type <code>document</code>, the engine searches for this value in every scope until it reaches the global scope <code>window</code>, where it finds the <code>window.document</code> property.</p>
<p>This makes <code>window.document</code> and <code>document</code> equivalent, so we can save a few keystrokes and leave out <code>window</code>.</p>


<section class="highlight-wrapper"><span class="caption">There&rsquo;s rarely any need to type window</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
// These two statements are equivalent
window.document;
document;
</code>
  </pre>
</section>

<p>This applies to any custom data to you add to <code>window</code> as well.</p>


<section class="highlight-wrapper">
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
window.yourData = {
  squirrels: &#39;nice&#39;
};

// Now these statements are equivalent
window.yourData;
yourData;
</code>
  </pre>
</section>

<p>There are lots of methods and properties attached to <code>window</code>, so we can avoid a bit of typing this way. For the rest of this chapter, we&rsquo;ll mostly omit <code>window</code>. However, this is not a rule so if at any point you feel it&rsquo;s more clear to include <code>window</code> in your code, feel free to do so.</p>
<h3 id="documenthead-and-documentbody">document.head and document.body</h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/head" target="_blank" rel="noopener noreferrer"><code>document.head</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/body" target="_blank" rel="noopener noreferrer"><code>document.body</code></a> refer the <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> elements in your HTML document. As we saw above, we can access and edit properties of these elements such as <code>document.body.style</code>.</p>
<h2 id="html-elements">HTML Elements</h2>
<p>HTML elements are represented using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element" target="_blank" rel="noopener noreferrer">the <code>Element</code> class</a>. Many of the DOM API methods that we&rsquo;ll encounter throughout this chapter are attached to every element.</p>
<h2 id="accessing-html-elements">Accessing HTML Elements</h2>
<p>The <code>.head</code> and <code>.body</code> can be accessed in a couple of keystrokes from anywhere in our code, but this is not the case for the rest of the elements on our page. This is because every valid HTML document will have both a <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code>, so it makes sense to provide shortcuts to these. Every other element is optional, however, so we&rsquo;ll have to do a little more work to access them.</p>
<h3 id="accessing-child-elements-using-elementchildren">Accessing Child Elements Using <code>element.children</code></h3>
<p>We can find all the child elements of a given element in the <a href="https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/children" target="_blank" rel="noopener noreferrer"><code>element.children</code></a> property. Given this page:</p>


<section class="highlight-wrapper"><span class="caption">Our simple HTML document again</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-html match-braces">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Page Title&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;h1&gt;A Heading&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code>
  </pre>
</section>

<p>&hellip; we&rsquo;ll find the <code>&lt;title&gt;</code> element in <code>document.head.children</code> and the <code>&lt;h1&gt;</code> element in <code>document.body.children</code>.</p>


<section class="highlight-wrapper"><span class="caption">An elements children are can be accessed via element.children</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
console.log(document.head.children);
// =&gt; HTMLCollection(1) [title]
</code>
  </pre>
</section>

<p><code>element.children</code> is read-only, so we cannot use this to add or remove elements from the page.</p>
<h3 id="queryselector-and-queryselectorall"><code>querySelector</code> and <code>querySelectorAll</code></h3>
<p>Accessing the <code>.children</code> property is fine for an extremely simple example like this, but web pages often consist of thousands of elements. To help us search through these and find the elements we need, the DOM API has lots of methods for selecting elements on the page.</p>
<p>In this book, we&rsquo;ll restrain ourselves to using just two of these selector functions: <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelector" target="_blank" rel="noopener noreferrer"><code>querySelector</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll" target="_blank" rel="noopener noreferrer"><code>querySelectorAll</code></a>. The difference between these is that <code>querySelector</code> will return only the first matching element, while <code>querySelectorAll</code> will return any number of matches.</p>
<p>If we have an HTML page like this:</p>


<section class="highlight-wrapper"><span class="caption">Adding some more elements to our HTML document</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-html match-braces">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;h1&gt;Title&lt;/h1&gt;

    &lt;div id=&#34;scene-container&#34;&gt;&lt;/div&gt;

    &lt;p class=&#34;alert&#34;&gt;Oh No!&lt;/p&gt;
    &lt;p class=&#34;alert&#34;&gt;Watch Out!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code>
  </pre>
</section>

<p>&hellip;we can access the elements individually using <code>querySelector</code>:</p>


<section class="highlight-wrapper"><span class="caption">document.querySelector returns the first matching element</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const html = document.querySelector(&#39;html&#39;);

const head = document.querySelector(&#39;head&#39;);

const title = document.querySelector(&#39;title&#39;);

const body = document.querySelector(&#39;body&#39;);

const heading = document.querySelector(&#39;h1&#39;);

const sceneContainer = document.querySelector(&#39;#scene-container&#39;);

// Return the first of the two alerts
const firstAlert = document.querySelector(&#39;.alert&#39;);
</code>
  </pre>
</section>

<p>In the last two examples, we use the <code>#</code> symbol to refer to an element by ID, and the <code>.</code> symbol to refer to a class, as we do in CSS.</p>
<p>If <code>querySelector</code> finds more than one matching element, it will return the first element and stop looking. Here, that means our <code>alertElem</code> variable will contain only the first of the two elements with an <code>alert</code> class. If we want <em>all</em> matching elements, we can use <code>querySelectorAll</code>.</p>


<section class="highlight-wrapper"><span class="caption">.querySelectorAll returns all matching elements</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const allAlertElements = document.querySelectorAll(&#39;.alert&#39;);
</code>
  </pre>
</section>

<p><code>allAlertElements</code> is a list of all matching elements, but it&rsquo;s not an array. Instead, it&rsquo;s a special array-like object called a <a href="https://developer.mozilla.org/en-US/docs/Web/API/NodeList" target="_blank" rel="noopener noreferrer"><code>NodeList</code></a>. You can use a <code>NodeList</code> in a similar manner to an array, however, it lacks many of the built-in array methods.</p>
<h3 id="most-dom-api-methods-are-available-on-all-elements">Most DOM API Methods are Available on All Elements</h3>
<p>These methods, like most DOM API methods, are available on all HTML elements. This means we don&rsquo;t have to search through the whole document every time we are looking for an element. This can improve the performance of your application a lot when dealing with huge web pages.</p>
<p>For example, using our above document again, we can search through the <code>document.body</code> for the <code>h1</code> element.</p>


<section class="highlight-wrapper"><span class="caption">Improve performance by avoiding searching through the entire document</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const bodyElem = document.querySelector(&#39;body&#39;);
const headingElem = bodyElem.querySelector(&#39;h1&#39;);

// alternatively:
const headingElem = document.body.querySelector(&#39;h1&#39;);
</code>
  </pre>
</section>

<h2 id="changing-the-text-in-an-element">Changing the Text in an Element</h2>
<p>There are many ways to change the text of an element, but we&rsquo;ll always use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent" target="_blank" rel="noopener noreferrer"><code>element.textContent</code></a>.</p>
<p>Let&rsquo;s use that to give our page a more interesting heading:</p>


<section class="highlight-wrapper"><span class="caption">Changing the text in the page heading</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const headingElem = document.querySelector(&#39;h1&#39;);

headElem.textContent = &#39;The Secret and Amazing Life of Honey Bees&#39;;
</code>
  </pre>
</section>

<h2 id="find-the-current-browser-window-width-and-height">Find the Current Browser Window Width and Height</h2>
<p>When using three.js we need to give our scenes a size pixels. Often, we want to match the same size as the browser window.</p>
<p>At any time, we can access the width and height of the browser window using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth" target="_blank" rel="noopener noreferrer"><code>window.innerWidth</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/innerHeight" target="_blank" rel="noopener noreferrer"><code>window.innerHeight</code></a>:</p>


<section class="highlight-wrapper"><span class="caption">The current size of the browser window</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const windowWidth = window.innerWidth;
const windowHeight = window.innerHeight;
</code>
  </pre>
</section>

<p>The value returned is in pixels, and you will see these values used a lot in three.js examples around the web. Any time the browser window size changes, these values will also change and we will need to update our scene. We&rsquo;ll see how to <a href="#listening-for-events">listen for <code>resize</code> events</a> in a few moments.</p>
<h2 id="find-an-elements-width-and-height">Find an Element&rsquo;s Width and Height</h2>
<p>We can access the width and height of an HTML element using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth" target="_blank" rel="noopener noreferrer"><code>element.clientWidth</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight" target="_blank" rel="noopener noreferrer"><code>element.clientHeight</code></a>.</p>
<p>In this book, we&rsquo;ll put our three.js scenes into a <code>#scene-container</code> element, set the size of that using CSS (either the full window size or a specific part of the window), and then use the width and height of the element to size our scene.</p>
<p>We&rsquo;ll mostly create full-screen examples throughout the book, so there&rsquo;s not much difference between using the container width or the full window width. However, the usefulness of this approach becomes apparent when you need to create scenes that <em>don&rsquo;t</em> take up the full page. In that case, we don&rsquo;t need to change any code, we simply change a couple of lines of CSS instead.</p>


<section class="highlight-wrapper"><span class="caption">Accessing the width and height of an element</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const sceneContainerElem = document.querySelector(&#39;#scene-container&#39;);

const sceneWidth = sceneContainerElem.clientWidth;
const sceneHeight = sceneContainerElem.clientHeight;
</code>
  </pre>
</section>

<p>There are other ways of getting information about an element&rsquo;s dimensions, such as <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetWidth" target="_blank" rel="noopener noreferrer"><code>.offsetWidth</code>/<code>.offsetHeight</code></a> which takes into account any borders and padding that may have been set in the CSS, and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollWidth" target="_blank" rel="noopener noreferrer"><code>.scrollWidth</code>/.scrollHeight</a>, which also includes parts of the element that may be off-screen.</p>
<h2 id="creating-new-elements">Creating New Elements</h2>
<p>There are many to create new HTML elements, but we&rsquo;ll stick to <code>document.createElement</code>](<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement">https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement</a>) to do this:</p>


<section class="highlight-wrapper"><span class="caption">Creating a new sub-heading element</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const headingElem = document.createElement(&#39;h2&#39;);

headingElem.textContent =
  &#39;Section Two: Waggle Dancing for Children and Teenagers&#39;;
</code>
  </pre>
</section>

<h3 id="adding-elements-to-our-page">Adding Elements to Our Page</h3>
<p>To add the newly created element to our page, we can use <a href="https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/append" target="_blank" rel="noopener noreferrer"><code>.append</code></a>.</p>
<p>Let&rsquo;s add our newly created <code>&lt;h2&gt;</code> as a child of the <code>&lt;body&gt;</code> element:</p>


<section class="highlight-wrapper"><span class="caption">Append the new element to our page</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
document.body.append(headingElem);
</code>
  </pre>
</section>

<p>Once added this way, our new <code>headingElem</code> will be immediately become visible, positioned after the <code>&lt;h1&gt;</code> that we created in HTML.</p>
<p>There&rsquo;s a similar method called <a href="https://developer.mozilla.org/en-US/docs/Web/API/Node/appendChild" target="_blank" rel="noopener noreferrer"><code>.appendChild</code></a>, that works <em>almost</em> the same way as <code>.append</code>. There are some technical differences between these two methods, but for our purposes, they are not important. We&rsquo;ll simply choose <code>.append</code> since it saves a few keystrokes.</p>
<h2 id="listening-for-events">Listening for Events</h2>
<p>One of the most important functions of a web application is <strong>reacting to change</strong>. In JavaScript, changes are called <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event" target="_blank" rel="noopener noreferrer">Events</a>, and there&rsquo;s <a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank" rel="noopener noreferrer">a huge list of events</a> to choose from.</p>
<p>One important category of events is user input such as
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event" target="_blank" rel="noopener noreferrer">clicks</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event" target="_blank" rel="noopener noreferrer">key presses</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/scroll_event" target="_blank" rel="noopener noreferrer">scrolling the mouse
wheel</a>, screaming, and so on. OK, not that last one. There are many other events returned by the browser, for example, when media such as video has loaded and is ready to play, or has finished playing, events related to CSS transitions and animation, and even events related to printing the current webpage. Another important event which we&rsquo;ll look at in a moment is <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/resize_event" target="_blank" rel="noopener noreferrer">the <code>resize</code> event</a>. We&rsquo;ll use this to update the size of our three.js scenes whenever the browser window changes size.</p>
<p>When we&rsquo;re talking about events, we sometimes refer to HTML elements as <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget" target="_blank" rel="noopener noreferrer"><strong>event targets</strong></a>.</p>
<h3 id="the-addeventlistener-method">The <code>addEventListener</code> Method</h3>
<p>To listen for events, we&rsquo;ll use something appropriately called an event listener. We can attach event listeners to nearly any HTML element, from the <code>window</code> itself, to the <code>document</code>, to sub-elements like headings, paragraphs, and buttons. If we attach an event listener (for example, a listener for mouse <code>click</code> events) to <code>window</code> or <code>document</code>, events will be captured on the whole page. However, if we attach the listener to a single element such as a button, the <code>click</code> events will only be captured when the button is clicked.</p>
<p>To attach an event listener to an element, we use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener" target="_blank" rel="noopener noreferrer"><code>element.addEventListener</code></a> method. This takes three arguments: the event type to listen for, a <a href="/book/appendix/javascript-reference/#callback-functions">callback function</a> specifying what to do when the event occurs, and optional options. We&rsquo;ll leave out the options here for the sake of brevity.</p>


<section class="highlight-wrapper"><span class="caption">Listen for click events on the whole window</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
window.addEventListener(&#39;click&#39;, (event) =&gt; {
  console.log(&#39;You clicked the mouse!&#39;);
} );
</code>
  </pre>
</section>

<p>As another example, let&rsquo;s say we have a button defined in HTML:</p>


<section class="highlight-wrapper"><span class="caption">An ominous button</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-html match-braces">
&lt;button id=&#34;risky-click-button&#34;&gt;Release the bees!&lt;/button&gt;
</code>
  </pre>
</section>

<p>We can listen for clicks on the button like this:</p>


<section class="highlight-wrapper"><span class="caption">Listen for events on the button</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const button = document.querySelector(&#39;#risky-click-button&#39;);

button.addEventListener(&#39;click&#39;, (event) =&gt; {
  console.log(&#39;Buzz buzz!! Buzz buzz!!&#39;);
});
</code>
  </pre>
</section>

<h3 id="the-event-argument">The <code>event</code> Argument</h3>
<p>The callback function receives a single argument, <code>event</code>, containing details about the event:</p>


<section class="highlight-wrapper"><span class="caption">The callback receives an object containing details about the event</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
window.addEventListener(&#39;click&#39;, (event) =&gt; {
  console.log(event);
});
</code>
  </pre>
</section>

<p><code>event</code> (often abbreviated to <code>evt</code>, <code>ev</code> or <code>e</code>) will be different for each event type. In this case, assuming the user is using a mouse and not a touchscreen, clicking anywhere on the page will return a <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent" target="_blank" rel="noopener noreferrer"><code>MouseEvent</code></a> which contains various data telling us where on the page the click landed, which mouse button was clicked, and so on.</p>
<h3 id="removing-event-listeners">Removing Event Listeners</h3>
<p>When we create a button that will always remain active, it&rsquo;s fine for an event listener to remain active until you close the page. However, it&rsquo;s best practice to clean up event listeners when you are done with them. There&rsquo;s a corresponding <code>.removeEventListener</code> method, but for that to work, we need to use a named callback.</p>


<section class="highlight-wrapper"><span class="caption">An event listener with a named callback</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const releaseBees = event =&gt; {
  console.log(&#39;Buzz buzz!! Buzz buzz!!&#39;);
};

button.addEventListener(&#39;click&#39;, releaseBees);
</code>
  </pre>
</section>

<p>Now we can remove the event listener:</p>


<section class="highlight-wrapper"><span class="caption">Using .removeEventListener to remove a listener</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
// on second thoughts, let&#39;s not release the bees...
button.removeEventListener(&#39;click&#39;, releaseBees);
</code>
  </pre>
</section>

<h3 id="prevent-the-default-behavior-of-an-event">Prevent the Default Behavior of an Event</h3>
<p>When we add the <code>click</code> event to the button above, clicking on the button still works as normal, by which we mean any functionality that a browser usually associates with buttons will be processed.</p>
<p>Often, that&rsquo;s not what we want. For example, we might want to use an <code>&lt;a&gt;</code> element instead of a button (a common, if questionable, practice):</p>


<section class="highlight-wrapper"><span class="caption">An anchor element masquerading as a button</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-html match-braces">
&lt;a class=&#34;button&#34; id=&#34;risky-click-button&#34; href=&#34;#&#34;&gt;Release the bees!&lt;/a&gt;
</code>
  </pre>
</section>

<p>Here, we&rsquo;ve styled the anchor element to look like a button using the <code>.button</code> class (details omitted). In this case, we <em>don&rsquo;t</em> want clicks on the link to exhibit normal link behavior such as redirecting to a new page.</p>
<p>To disable the default behavior, we&rsquo;ll call <a href="https://developer.mozilla.org/en-US/docs/Web/API/Event/preventDefault" target="_blank" rel="noopener noreferrer"><code>event.preventDefault</code></a> in the callback. Only our custom behavior will be processed.</p>


<section class="highlight-wrapper"><span class="caption">.preventDefault prevents default event behavior</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const fakeButton = document.querySelector(&#39;#risky-click-button&#39;);

fakeButton.addEventListener(&#39;click&#39;, (event) =&gt; {
  event.preventDefault();

  console.log(&#39;Buzz buzz!! Buzz buzz!!&#39;);
});
</code>
  </pre>
</section>

<h3 id="the-resize-event">The <code>resize</code> Event</h3>
<p>Another important event is the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/resize_event" target="_blank" rel="noopener noreferrer"><code>resize</code></a> event, which occurs when the browser window changes size. This also occurs when a user rotates their phone from portrait to landscape mode.</p>


<section class="highlight-wrapper"><span class="caption">Listening for the resize event</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
window.addEventListener(&#39;resize&#39;, () =&gt; {
  console.log(&#39;The new width is:&#39;, window.innerWidth);
  console.log(&#39;The new height is:&#39;, window.innerHeight);
});
</code>
  </pre>
</section>

<p>Note that the <code>resize</code> event won&rsquo;t work when attached to anything other than the <code>window</code>:</p>


<section class="highlight-wrapper"><span class="caption">The resize event must be added to the entire window</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
// this won&#39;t work!
document.addEventListener(&#39;resize&#39;, onResizeCallback);
</code>
  </pre>
</section>

<h2 id="the-virtual-viewport">The Virtual Viewport</h2>
<p>Mobile devices render your page in a <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Mobile/Viewport_meta_tag" target="_blank" rel="noopener noreferrer">virtual viewport</a>, then scale it and draw it onto the physical device screen. <strong>These virtual pixels (<strong>CSS pixels</strong>) may not be the same size as the device&rsquo;s physical pixels</strong>. They often differ by a factor of between two and five. This is known as the device&rsquo;s pixel ratio.</p>
<h3 id="the-device-pixel-ratio">The Device Pixel Ratio</h3>
<p>We&rsquo;ll need to take the pixel ratio into account when we set the size of three.js scenes to make sure rendered images are not blurry on mobile devices. We can access this value using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio" target="_blank" rel="noopener noreferrer"><code>window.devicePixelRatio</code></a>:</p>


<section class="highlight-wrapper"><span class="caption">The pixel ratio is the difference between physical pixels in the screen and CSS pixels</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const pixelRatio = window.devicePixelRatio;
</code>
  </pre>
</section>

<h2 id="drawing-animation-frames">Drawing Animation Frames</h2>
<p>Usually, our three.js scene will contain movement. This means drawing frames - lots of frames! Ideally, we want to draw 60 frames per second. Modern browsers have a function designed to help us with this called <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener noreferrer"><code>window.requestAnimationFrame</code></a>. Since <code>requestAnimationFrame</code> is part of the DOM API, it&rsquo;s not available in other environments such as Node.js.</p>
<p>We&rsquo;ll cover how this works in a lot more detail in <a href="/book/first-steps/animation-loop/#the-solution-requestanimationframe">1.7: The Animation Loop</a> when we set up our animation loop.</p>
<p>That&rsquo;s it for our exploration of the DOM and DOM API. We&rsquo;ve touched only a fraction of the functionality added to JavaScript by the web browser here, but we&rsquo;ve covered everything you need to follow the examples in this book. In this chapter and the last, we&rsquo;ve covered a lot of syntax. In the next chapters, we&rsquo;ll take a deeper look at the reality of using JavaScript to build applications. First up is a deep dive into JavaScript modules.</p>
