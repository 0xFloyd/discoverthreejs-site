<h1 id="making-our-scenes-responsive-and-also-dealing-with-jaggies">Making Our Scenes Responsive (and also Dealing with Jaggies)</h1>
<p>Welcome back! The last chapter was a long one, stuffed full of mathematical and computer graphics theory. Here, we&rsquo;ll slow things down a little and look at the current state of our app.</p>
<p>Since we created <a href="/book/first-steps/world-app/">the World app</a> a couple of chapters ago, our code is well structured and ready to be expanded as we add features over the coming chapters. Next, we switched to <a href="/book/first-steps/physically-based-rendering/">physically correct lighting and rendering</a> and explained how we&rsquo;ll (nearly always) build our scenes using meters for measurement. Our brains are tuned to appreciate physically correct lighting and colors, so when we set up our scenes this way a lot of the hard work of making them look great is done for us. This applies even to scenes with a cartoony or abstract look.</p>
<p>In the last chapter, we explored the coordinate systems and mathematical operations called transformations that are used to move objects around in 3D space. Over the next couple of chapters, we&rsquo;ll use everything we have learned so far and start to create scenes that are more interesting than a single cube.</p>
<p>But first, take a closer look at the cube:</p>
<figure class="left small noborder">
  <img src="/static/images/first-steps/cube-medium.png" loading="lazy" alt="Our humble cube" title="Our humble cube"  /></figure>
<p>Closer&hellip;</p>
<figure class="large noborder">
  <img src="/static/images/first-steps/cube-medium.png" loading="lazy" alt="Our humble cube is getting closer" title="Our humble cube is getting closer"  /></figure>
<p>Even closer&hellip;</p>
<figure class="noborder">
  <img src="/static/images/first-steps/cube-closeup-text.png" loading="lazy" alt="Not until you see the white of it&#39;s eyes!" title="Not until you see the white of it&#39;s eyes!"  /></figure>
<p>Look closely at the cube&rsquo;s edges. Can you see that they are not straight, but rather look jagged and unclean? Technically, this is called <strong>aliasing</strong>, but informally we refer to these as jaggies. Ugh&hellip;</p>
<p>There&rsquo;s another problem. Try resizing the preview window in the editor and you&rsquo;ll see that the scene does not adapt to fit the new size (the preview might refresh too fast to see this easily, in which case, try popping it out into a new window using the {% include 'partials/icons/solid/external-link-alt.svg' %} button). <strong>In the language of web design, our scene is not <em>responsive</em></strong>. In this chapter, we&rsquo;ll fix both of these issues.</p>
<h2 id="antialiasing">Anti-Aliasing</h2>
<figure >
  <img src="/static/images/first-steps/antialias.svg" loading="lazy" alt="Anti-alias on and off" title="Anti-alias on and off"  /></figure>
<p>It turns out that drawing straight lines using square pixels is hard unless the straight lines are exactly horizontal or vertical. We&rsquo;ll use a technique called <strong>anti-aliasing</strong> (<strong>AA</strong>) to counter this.</p>
<h3 id="enable-anti-aliasing">Enable Anti-Aliasing</h3>
<p>We can turn on anti-aliasing by passing a single new parameter into the <code>WebGLRenderer</code> constructor.  As with <a href="/book/first-steps/physically-based-rendering/#change-the-material-s-color">the <code>MeshStandardMaterial</code></a>, the <code>WebGLRenderer</code> constructor takes a specification object with named parameters. Here, we will set the <code>antialias</code> parameter to <code>true</code>:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>renderer.js</strong></em>: Enable antialiasing</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="3"
    data-line="4"
    data-line-offset="3"
    >
    <code class="highlight language-js match-braces">function createRenderer() {
  const renderer = new WebGLRenderer({ antialias: true });

  renderer.physicallyCorrectLights = true;

  return renderer;
}
</code>
  </pre>
</section>

<p>Note that <strong>you can&rsquo;t change this setting once you have created the renderer</strong>. To change it, you need to create an entirely new renderer. That&rsquo;s rarely a problem though since you&rsquo;ll want this on for most scenes.</p>
<h3 id="multisample-anti-aliasing-msaa">Multisample Anti-Aliasing (MSAA)</h3>
<p><strong>Anti-aliasing is performed using the built-in WebGL method, which is <a href="https://en.wikipedia.org/wiki/Multisample_anti-aliasing" target="_blank" rel="noopener noreferrer">multisample anti-aliasing</a> (MSAA)</strong>. Depending on your browser and graphics card, there&rsquo;s a chance this will be unavailable or disabled, although on modern hardware that&rsquo;s unlikely. If your app does end up running on a device without MSAA, this setting will be ignored, but your scene will be otherwise unaffected.</p>
<p>MSAA is not a perfect solution, and there will be scenes that still display aliasing, even with AA enabled. In particular, scenes with many long, thin straight lines (such as wire fences, or telephone lines) are notoriously hard to remove aliasing from. If possible, avoid creating such scenes. On the other hand, some scenes look fine without AA, in which case you might choose to leave it switched off. On the powerful GPU in a laptop, you are unlikely to notice any difference in performance. However, mobile devices are a different story and you might be able to gain a few precious frames per second by disabling AA.</p>
<p>Other anti-aliasing techniques such as SMAA and FXAA are available as post-processing passes, as we&rsquo;ll see later in the book. However, these passes are performed on the CPU, while MSAA is done on the GPU (for most devices), so you may see a drop in performance if you use another technique, again, especially on mobile devices.</p>
<h2 id="seamless-resize">Seamlessly Handling Browser Window Size Changes</h2>
<p>Currently, our app cannot handle a user doing something as simple as rotating their phone or resizing their browser. <strong>We need to handle resizing gracefully, in an automatic manner that&rsquo;s invisible to our users</strong>, and which involves a minimum of effort on our part. Unlike anti-aliasing, there&rsquo;s no magic setting to fix this. However, we already have a <code>Resizer</code> class, so here, we&rsquo;ll extend this to reset the size whenever the window changes size. After all, that&rsquo;s why we called this class a <a href="/book/first-steps/world-app/#systems-the-resizer-module-1">Re-sizer</a> in the first place.</p>
<h3 id="listen-for-resize-events-on-the-browser-window">Listen for <code>resize</code> Events on the Browser Window</h3>
<p>First, we need some way of listening to the browser and then taking action when the window&rsquo;s size changes. In web-dev terminology, we want to <strong>listen for resize events</strong>. A built-in browser method called <code>element.addEventListener</code> makes our work easy here. We can use this method to listen for all kinds of events, such as <code>click</code>, <code>scroll</code>, <code>keypress</code>, and many more, on any HTML element. Whenever an event occurs, we say <strong>the event has fired</strong>. When a user clicks their mouse, the <code>click</code> event will fire, when they spin their scroll wheel, the <code>scroll</code> event will fire, when they resize the browser window, the <code>resize</code> event will fire, and so on.</p>
<p>Later, we&rsquo;ll use event listeners to add interactivity to our scenes. Here, we want to listen for the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/resize_event" target="_blank" rel="noopener noreferrer"><code>resize</code></a> event, which fires whenever the browser&rsquo;s window size changes. Rotating a mobile device from landscape to portrait, dragging a window between monitors on a multi-monitor setup, and resizing the browser by dragging the edges of the window with a mouse all cause the <code>resize</code> event to fire, which means the code we add here will handle all of these scenarios.</p>
<p><em>If you are unfamiliar with event listeners, check out the <a href="/book/appendix/dom-api-reference/#listening-for-events">DOM API reference</a> in the appendices for more info.</em></p>
<p>We can listen for most events, like <code>click</code>, or <code>scroll</code>, on any HTML element. However, the <code>resize</code> event listener must be attached to <a href="/book/appendix/dom-api-reference/#global-object">the global <code>window</code> object</a>. There is another way of listening for resize events which works with any element: the <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/ResizeObserver" target="_blank" rel="noopener noreferrer"><code>ResizeObserver</code></a>. However, it&rsquo;s quite new and at the time of writing this chapter isn&rsquo;t yet widely supported. Besides, it&rsquo;s a little more work to set up, so we&rsquo;ll stick with the tried and trusted <code>resize</code> event for now.</p>
<h3 id="test-addeventlistener-in-the-browser-console">Test <code>addEventListener</code> in the Browser Console</h3>
<p>Before we set up automatic resizing in our app, we&rsquo;ll use the browser console to test <code>addEventListener</code> and the <code>resize</code> event. Open your browser console by pressing the F12 key, paste in the following code, then press <em>Enter</em>:</p>


<section class="highlight-wrapper"><span class="caption">Paste this code into your browser console then resize the page</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
function onResize() {
  console.log(&#39;You resized the browser window!&#39;);
}

window.addEventListener(&#39;resize&#39;, onResize);
</code>
  </pre>
</section>

<figure class="medium right">
  <img src="/static/images/first-steps/console-resize.png" loading="lazy" alt="Logging resize event to console" title="Logging resize event to console"  /></figure>
<p>This will call the <code>onResize</code> function every time the window resizes. Once you&rsquo;ve entered the code, try resizing your browser while keeping an eye on the console. You should see something like the following image.</p>
<p>When we resize the window, the <code>onResize</code> callback might get called many times. You might think you have performed a single resize, but find the <code>resize</code> event has fired ten times or more. As a result, doing too much work in <code>onResize</code> can cause stuttering. It&rsquo;s important to keep this function simple.</p>
<blockquote>
<p>Don&rsquo;t do heavy calculations in the resize function.</p>
</blockquote>
<p>If you find this function growing in size, you might consider using a throttling function such as <a href="https://lodash.com/docs#throttle" target="_blank" rel="noopener noreferrer">lodash&rsquo;s <code>_.throttle</code></a> to prevent it from being called too often.</p>
<h3 id="extend-the-resizer-class">Extend the Resizer Class</h3>
<p>Now that we&rsquo;ve confirmed everything works as expected, we&rsquo;ll go ahead and extend the <code>Resizer</code> class to automatically handle resizing. That means we need to call the sizing code in two situations: first, on load, to set the initial size, and then again whenever the size changes.  So, let&rsquo;s move that code into a separate function, and then call it once when our scene loads:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Resizer.js</strong></em>: move the sizing code into a setSize function and call it on load</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line="1-7,12"
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">

const setSize = (container, camera, renderer) =&gt; {
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();

  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
};

class Resizer {
  constructor(container, camera, renderer) {
    // set initial size on load
    setSize(container, camera, renderer);
  }
}

export { Resizer };

</code>
  </pre>
</section>

<p>Great. Now, let&rsquo;s add an event listener and call <code>setSize</code> again whenever the event fires.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Resizer.js</strong></em>: set up the event listener</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="9"
    data-line="14-17"
    data-line-offset="9"
    >
    <code class="highlight language-js match-braces">

class Resizer {
  constructor(container, camera, renderer) {
    // set initial size
    setSize(container, camera, renderer);

    window.addEventListener(&#39;resize&#39;, () =&gt; {
      // set the size again if a resize occurs
      setSize(container, camera, renderer);
    });
  }
}

</code>
  </pre>
</section>

<figure class="medium left">
  <img src="/static/images/first-steps/cube-stretched.png" loading="lazy" alt="Cube abuse!" title="Cube abuse!"  />
    <figcaption>Cube abuse!</figcaption></figure>
<p>Now, <code>setSize</code> is called whenever the <code>resize</code> event fires. However, we&rsquo;re not quite done yet. If you try resizing the window now, you&rsquo;ll see that the scene does expand or contract to fit the new window size. However, weird things are happening to the cube. It seems to be getting squashed and stretched instead of resizing with the window. What&rsquo;s going on?</p>
<figure class="medium right">
  <img src="/static/images/first-steps/cube-flattened.png" loading="lazy" alt="Oh, the humanity!" title="Oh, the humanity!"  />
    <figcaption>Oh, the humanity!</figcaption></figure>
<p style="clear:both; margin: 0; padding: 0; line-height: 0;">&nbsp</p>
<p>The camera, renderer, and <code>&lt;canvas&gt;</code> element are all being resized correctly. However, we&rsquo;re only calling <code>.render</code> a single time, which draws a single frame into the canvas. When the canvas is resized, this frame is stretched to fit the new size.</p>
<h3 id="create-an-onresize-hook">Create an <code>onResize</code> Hook</h3>
<p>This means we need to generate a new frame every time the resize event fires. To do this, we need to call <code>World.render</code> right after <code>setSize</code>, inside the event listener in the <code>Resizer</code> class. However,  we&rsquo;d rather not pass the entire World class into Resizer. Instead, we&rsquo;ll create a <code>Resizer.onResize</code> hook. This enables us to perform some custom behavior whenever a resize happens.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Resizer.js</strong></em>: an empty onResize method for custom resizing behavior</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="9"
    data-line="18,22"
    data-line-offset="9"
    >
    <code class="highlight language-js match-braces">class Resizer {
  constructor(container, camera, renderer) {
    // set initial size on load
    setSize(container, camera, renderer);

    window.addEventListener(&#39;resize&#39;, () =&gt; {
      // set the size again if a resize occurs
      setSize(container, camera, renderer);
      // perform any custom actions
      this.onResize();
    });
  }

  onResize() {}
}
</code>
  </pre>
</section>

<p><code>.onResize</code> is an <a href="/book/appendix/javascript-reference/#empty-functions">empty method</a> that we can customize from outside the <code>Resizer</code> class.</p>
<h3 id="customize-resizeronresize-in-world">Customize <code>Resizer.onResize</code> in World</h3>
<p>Over in World, replace the empty <code>.onResize</code> with a new one that calls <code>World.render</code>.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: customise Resizer.onResize</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="14"
    data-line="26-28"
    data-line-offset="14"
    >
    <code class="highlight language-js match-braces">  constructor(container) {
    camera = createCamera();
    scene = createScene();
    renderer = createRenderer();
    container.append(renderer.domElement);

    const cube = createCube();
    const light = createLights();

    scene.add(cube, light);

    const resizer = new Resizer(container, camera, renderer);
    resizer.onResize = () =&gt; {
      this.render();
    };
  }
</code>
  </pre>
</section>

<p>With that, automatic resizing is complete.</p>
<p>Now that automatic resizing and antialiasing are working, our app looks much more professional. In the next chapter, we&rsquo;ll set up an animation loop, which will spit out a steady stream of frames at a rate of sixty per second. Once we do that, we&rsquo;ll no longer need to worry about re-rendering the frame after resizing.</p>
<h2 id="challenges">Challenges</h2>
<aside class="success">
  
    <h3 id="easy">Easy</h3>
<ol>
<li>
<p>Enable and disable AA and compare the difference.</p>
</li>
<li>
<p>Rotate the cube until the edges are vertical and horizontal. Now, can you see any difference with AA disabled?</p>
</li>
<li>
<p>Comment out the code for resizing in <em><strong>World.js</strong></em> and compare the difference when you resize the window.</p>
</li>
<li>
<p>Comment out the custom <code>onResize</code> hook in <em><strong>World.js</strong></em> and see what happens when you resize the window.</p>
</li>
</ol>

  
</aside>
<aside class="notice">
  
    <h3 id="medium">Medium</h3>
<ol>
<li>
<p>Disable antialiasing. Now, zoom in on the cube to get a better view of the aliasing artifact. Don&rsquo;t use your browser&rsquo;s zoom function. Instead, try these methods:</p>
<ul>
<li>Enlarge the cube using <code>cube.scale</code>.</li>
<li>Bring the cube closer to you using <code>cube.position.z</code>.</li>
<li>Bring the camera closer to the cube using <code>camera.position.z</code> <br><br></li>
</ul>
</li>
<li>
<p>Still with AA disabled, use <code>camera.position.x</code> (horizontal movement) and <code>camera.position.y</code> (vertical movement) to zoom in on the right-hand corner of the cube.</p>
</li>
<li>
<p>Repeat 2., but this time, use <code>cube.position.x</code> and <code>cube.position.y</code>.</p>
</li>
</ol>
<p><em>Note how aliasing artifacts (jaggies) change as you move the cube around or zoom in and out.</em></p>

  
</aside>
<aside class="warning">
  
    <h3 id="hard">Hard</h3>
<ol>
<li>
<p>Instead of using the container to size the scene, try entering some numbers manually. For example, create a scene that is 64 pixels wide and high, or 256 pixels wide and high. You might want to change the scene&rsquo;s background color here to see this more easily.</p>
</li>
<li>
<p>Play with the <code>devicePixelRatio</code>. Try setting a higher value for DPR, like 4 or 8 (don&rsquo;t go too high though!). What happens if you set a value below 1, like 0.5? What happens if you set a high value for DPR and disable AA? How do the edges of the cube look?</p>
</li>
</ol>
<p><em><code>devicePixelRatio</code> values other than 1 render the scene at a higher or low resolution and then scale it to fit in the canvas. A DPR of 2 will render the scene at double resolution and scale down, while a DPR of 0.5 will render at half resolution and scale up. As you can imagine, high DPR values are very expensive to render!</em></p>

  
</aside>
