<h1 id="extend-threejs-with-a-camera-controls-plugin">Extend three.js With a Camera Controls Plugin</h1>
<p>The three.js core is a powerful, lightweight, and focused <strong>rendering framework</strong>, with intentionally limited capabilities. It has everything you need to create and render physically correct scenes, however, it does not have everything you need to create, say, a game, or a product configurator. Even when building relatively simple apps, you will often find yourself needing functionality that&rsquo;s not in the core. When this happens, before you write any code yourself, check to see whether there&rsquo;s a plugin available. The three.js repo contains hundreds of extensions, in the <a href="https://github.com/mrdoob/three.js/tree/master/examples/jsm" target="_blank" rel="noopener noreferrer"><em><strong>examples/jsm</strong></em></a> folder. These are also included in <a href="https://www.npmjs.com/package/three" target="_blank" rel="noopener noreferrer">the NPM package</a>, for those of you using a package manager.</p>
<p>There are also a huge number of plugins to be found scattered around the web. However, these are sometimes poorly maintained and may not work with the latest three.js version, so in this book, we&rsquo;ll restrict ourselves to using the official plugins from the repo. There, we&rsquo;ll find all kinds of plugins, and most of them are showcased in one of <a href="https://threejs.org/examples/" target="_blank" rel="noopener noreferrer">the examples</a>. These add all kinds of functionality, such as mirrored surfaces:</p>
<figure class="">
  <iframe title="three.js node materials mirror example" width="100%" height="500px" src="https://threejs.org/examples/webgl_mirror_nodes.html" importance="low" loading="lazy" sandbox="allow-scripts"></iframe></figure>
<p>Or, how about a loader for the Lego LDraw format:</p>
<figure class="">
  <iframe title="three.js LDraw format example" width="100%" height="500px" src="https://threejs.org/examples/webgl_loader_ldraw.html" importance="low" loading="lazy" sandbox="allow-scripts"></iframe></figure>
<p>Here are a few more:</p>
<ul>
<li><a href="https://threejs.org/examples/?q=postprocessing#webgl_postprocessing_glitch" target="_blank" rel="noopener noreferrer">One of the many post-processing effects</a></li>
<li><a href="https://threejs.org/examples/?q=loader#webgl_loader_fbx" target="_blank" rel="noopener noreferrer">A loader for the Autodesk FBX format</a></li>
<li><a href="https://threejs.org/examples/?q=exporter#misc_exporter_gltf" target="_blank" rel="noopener noreferrer">An exporter for glTF format</a></li>
<li><a href="https://threejs.org/examples/?q=ocean#webgl_shaders_ocean" target="_blank" rel="noopener noreferrer">Physically accurate ocean and sky</a></li>
</ul>
<p>Each extension is stored in a separate module in <em><strong>examples/jsm</strong></em>, and to use them, we simply import them into our app, much like any other three.js class.</p>
<h2 id="our-first-plugin-orbitcontrols">Our First Plugin: <code>OrbitControls</code></h2>
<p>One of the most popular extensions is <a href="https://threejs.org/docs/#examples/en/controls/OrbitControls" target="_blank" rel="noopener noreferrer"><code>OrbitControls</code></a>, a camera controls plugin which allows you to orbit, pan, and zoom the camera using touch, mouse, or keyboard. With these controls, we can view a scene from all angles, zoom in to check tiny details, or zoom out to get a birds-eye overview. Orbit controls allow us to control the camera in three ways:</p>
<ol>
<li><strong>Orbit around a fixed point, using the left mouse button or a single finger swipe.</strong></li>
<li><strong>Pan the camera using the right mouse button, the arrow keys, or a two-finger swipe.</strong></li>
<li><strong>Zoom the camera using the scroll wheel or a pinch gesture.</strong></li>
</ol>
<p>You can find the module containing <code>OrbitControls</code> on the three.js repo, in the <em><strong>examples/jsm/controls/</strong></em> folder, in a file called <em><strong><a href="https://github.com/mrdoob/three.js/blob/master/examples/jsm/controls/OrbitControls.js" target="_blank" rel="noopener noreferrer">OrbitControls.js</a></strong></em>. There&rsquo;s also an <a href="https://threejs.org/examples/?q=controls#misc_controls_orbit" target="_blank" rel="noopener noreferrer">official example showcasing <code>OrbitControls</code></a>. For a quick reference of all the control&rsquo;s settings and features, head over to the <a href="https://threejs.org/docs/#examples/en/controls/OrbitControls" target="_blank" rel="noopener noreferrer"><code>OrbitControls</code> doc page</a>.</p>
<h3 id="importing-plugins">Importing Plugins</h3>
<p>Since the plugins are part of the three.js repo and included in the NPM package, importing them works in much the same way as <a href="/book/first-steps/first-scene/#import-classes-from-threejs">importing classes from the three.js core</a>, except that each plugin is in a separate module. Refer back to <a href="/book/introduction/get-threejs/">0.5: How to Include three.js in Your Projects</a> for a reminder of how to include the three.js files in your app, or head over to <a href="/book/appendix/javascript-modules/">A.4: JavaScript Modules</a> for a deeper exploration of how JavaScript modules work.</p>
<p>In the editor, we&rsquo;ve placed the <em><strong>OrbitControls.js</strong></em> file in the equivalent directory to the repo, under <em><strong>vendor/</strong></em>. Go ahead and locate the file now. Since the editor uses NPM style imports, we can import <code>OrbitControls</code> like this, from anywhere in our code like this:</p>


<section class="highlight-wrapper"><span class="caption">Importing the <code>OrbitControls</code> extension using NPM style imports</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
import { OrbitControls } from &#39;three/examples/jsm/controls/OrbitControls.js&#39;;
</code>
  </pre>
</section>

<p>Once again, if you’re working locally and not using a bundler, you’ll have to change the import path. For example, you can import from unpkg.com instead.</p>


<section class="highlight-wrapper"><span class="caption">Importing the <code>OrbitControls</code> extension using relative imports</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
import { OrbitControls } from &#39;https://unpkg.com/three@0.117.0/examples/jsm/controls/OrbitControls.js&#39;;
</code>
  </pre>
</section>

<blockquote>
<p>Important note: Make sure you import plugins from <em><strong>examples/jsm/</strong></em> and not legacy plugins from <em><strong>examples/js/</strong></em>!</p>
</blockquote>
<h3 id="the-_controlsjs_-module">The <em><strong>controls.js</strong></em> Module</h3>
<p>As usual, we&rsquo;ll create a new module in our app to handle setting up the controls. Since the controls operate on the camera, they will go in the <a href="/book/first-steps/world-app/#systems-and-components">systems category</a>. Open or create the module <em><strong>systems/controls.js</strong></em> to handle setting up the camera controls. This new module has the same structure as most of our other modules. First, import the <code>OrbitControls</code> class, then make a <code>createControls</code> function, and finally, export the function:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>systems/controls.js</strong></em>: initial setup</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
import { OrbitControls } from &#39;three/examples/jsm/controls/OrbitControls.js&#39;;

function createControls() {}

export { createControls };
</code>
  </pre>
</section>

<p>Back over in World, add the new function to the list of imports:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: import the controls module</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line="6"
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">import { createCamera } from &#39;./components/camera.js&#39;;
import { createCube } from &#39;./components/cube.js&#39;;
import { createLights } from &#39;./components/lights.js&#39;;
import { createScene } from &#39;./components/scene.js&#39;;

import { createControls } from &#39;./systems/controls.js&#39;;
import { createRenderer } from &#39;./systems/renderer.js&#39;;
import { Resizer } from &#39;./systems/Resizer.js&#39;;
import { Loop } from &#39;./systems/Loop.js&#39;;
</code>
  </pre>
</section>

<p>Next, call the function and store the result in a variable called <code>controls</code>. While you&rsquo;re here, comment out the line adding <code>cube</code> to the <code>updatables</code> array. This will stop the cube from rotating and make the effect of the controls easier to see:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: stop the cube&rsquo;s animation</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="17"
    data-line="22,27,28"
    data-line-offset="17"
    >
    <code class="highlight language-js match-braces">

  constructor() {
    camera = createCamera();
    scene = createScene();
    renderer = createRenderer();

    const controls = createControls();

    const cube = createCube();
    const light = createLights();

    // disabled mesh rotation
    // updatables.push(cube);

    scene.add(cube, light);

    this.canvas = renderer.domElement;
  }

</code>
  </pre>
</section>

<h3 id="initialize-the-controls">Initialize the Controls</h3>
<p>If you check out the <a href="https://threejs.org/docs/#examples/en/controls/OrbitControls" target="_blank" rel="noopener noreferrer"><code>OrbitControls</code> docs page</a>, you&rsquo;ll see that the constructor takes two parameters: a <code>Camera</code>, and a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element" target="_blank" rel="noopener noreferrer"><code>HTMLDOMElement</code></a>. We&rsquo;ll use our camera for the first parameter and the canvas, stored in <code>renderer.domElement</code>, for the second.</p>
<p>Internally, <code>OrbitControls</code> uses <code>addEventListener</code> to listen for user input. The controls will listen for events such as  <code>click</code>, <code>wheel</code>, <code>touchmove</code>, and <code>keydown</code>, amongst others, and use these to move the camera. We previously used this method to <a href="/book/first-steps/responsive-design/#listen-for-resize-events-on-the-browser-window">listen for the <code>resize</code> event</a> when we set up automatic resizing. There, we listened for the <code>resize</code> event on the entire <code>window</code>. Here, the controls will listen for user input on whatever element we pass in as the second parameter. The rest of the page will be unaffected. In other words, when we pass in the canvas, the controls will work when the mouse/touch is over the canvas, but the rest of the page will continue to work as normal.</p>
<p>Pass the camera and canvas into the <code>createControls</code> function, then create the controls:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>controls.js</strong></em>: create the controls</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="3"
    data-line=""
    data-line-offset="3"
    >
    <code class="highlight language-js match-braces">
function createControls(camera, canvas) {
  const controls = new OrbitControls(camera, canvas);

  return controls;
}
</code>
  </pre>
</section>

<p>Back over in the world module, pass in the <code>camera</code> and <code>renderer.domElement</code>:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: initialize the controls</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="18"
    data-line="24"
    data-line-offset="18"
    >
    <code class="highlight language-js match-braces">

constructor(container) {
  camera = createCamera();
  scene = createScene();
  renderer = createRenderer();
  container.append(renderer.domElement);

  const controls = createControls(camera, renderer.domElement);

  // ...
}

</code>
  </pre>
</section>

<p>With that, the controls should start to work. Take them for a spin!</p>
<p>You&rsquo;ll immediately notice <a href="#a-glaring-problem">the cube is not illuminated from the back</a>. We&rsquo;ll explain why and how to fix this in the next chapter.</p>
<h2 id="working-with-the-controls">Working with the Controls</h2>
<h3 id="manually-set-the-target">Manually Set the Target</h3>
<p>By default, the controls orbit around the center of the scene, point $(0,0,0)$. This is stored in the <code>controls.target</code> property, which is a <code>Vector3</code>. We can move this target to a new position:</p>


<section class="highlight-wrapper"><span class="caption">Set the control&rsquo;s target</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.target.set(1,2,3);
</code>
  </pre>
</section>

<p>We can also point the controls at an object by copying the object&rsquo;s position.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: target an object</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.target.copy(cube.position);
</code>
  </pre>
</section>

<p>Whenever you pan the controls (using the right mouse button), the target will pan too. If you need a fixed target, you can disable panning using <code>controls.enablePan = false</code>.</p>
<h3 id="enable-damping-for-added-realism">Enable Damping for Added Realism</h3>
<p>As soon as the user stops interacting with the scene, the camera will come to an abrupt stop. Objects in the real world have inertia and never stop abruptly like this, so we can make the controls feel more realistic by enabling <a href="https://threejs.org/docs/index.html#examples/en/controls/OrbitControls.enableDamping" target="_blank" rel="noopener noreferrer">damping</a>.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>controls.js</strong></em>: enable damping</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.enableDamping = true;
</code>
  </pre>
</section>

<p>With damping enabled, the controls will slow to a stop over several frames which gives them a feeling of
weight. You can adjust <a href="https://threejs.org/docs/#examples/en/controls/OrbitControls.dampingFactor" target="_blank" rel="noopener noreferrer">the <code>.dampingFactor</code></a> to control how fast the camera comes to a stop. However, for damping to work, we must call <code>controls.update</code> every frame in the animation loop. If we&rsquo;re <a href="#rendering-on-demand-with-orbitcontrols">rendering frames on demand</a> instead of using the loop, we cannot use damping.</p>
<h3 id="update-the-controls-in-the-animation-loop">Update the Controls in the Animation Loop</h3>
<p>Whenever we need to update an object in the loop, we&rsquo;ll use the technique we devised when creating <a href="/book/first-steps/animation-loop/#create-the-animation">the cube&rsquo;s animation</a>. In other words, we&rsquo;ll give the controls a <code>.tick</code> method and then add them to the <code>loop.updatables</code> array. First, the <code>.tick</code> method:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>controls.js</strong></em>: add controls.tick</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="3"
    data-line="12"
    data-line-offset="3"
    >
    <code class="highlight language-js match-braces">function createControls(camera, canvas) {
  const controls = new OrbitControls(camera, canvas);

  // damping and auto rotation require
  // the controls to be updated each frame

  // this.controls.autoRotate = true;
  controls.enableDamping = true;

  controls.tick = () =&gt; controls.update();

  return controls;
}
</code>
  </pre>
</section>

<p>Here, <code>.tick</code> simply calls <code>controls.update</code>. Next, add the controls to the <code>updatables</code> array:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: add the controls to the updatables array</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="18"
    data-line="29"
    data-line-offset="18"
    >
    <code class="highlight language-js match-braces">    camera = createCamera();
    renderer = createRenderer();
    scene = createScene();
    loop = new Loop(camera, scene, renderer);
    container.append(renderer.domElement);

    const controls = createControls(camera, renderer.domElement);

    const cube = createCube();
    const light = createLights();

    loop.updatables.push(controls);

    // stop the cube&#39;s animation
    // loop.updatables.push(cube);

    scene.add(cube, light);

    const resizer = new Resizer(container, camera, renderer);
  }
</code>
  </pre>
</section>

<p>Now, <code>controls.tick</code> will be called once per frame in <a href="/book/first-steps/animation-loop/#the-update-loop">the update loop</a>, and damping will work. Test it out. Can you see the difference?</p>
<h3 id="working-with-the-camera-while-using-orbitcontrols">Working With the Camera While Using <code>OrbitControls</code></h3>
<p>With the controls in place, we have relinquished control of the camera to them. However, sometimes you need to take back control to manually position the camera. There are two ways to go about this:</p>
<ol>
<li>Cut/jump to a new camera position</li>
<li>Smoothly animate to a new camera position</li>
</ol>
<p>We&rsquo;ll take a brief look at how you would go about both of these, but we won&rsquo;t add the code to our app.</p>
<h4 id="cut-to-a-new-camera-position">Cut to a New Camera Position</h4>
<p>To perform a camera cut, update the camera&rsquo;s transform as usual, and then call <code>controls.update</code>:</p>


<section class="highlight-wrapper"><span class="caption">Manually adjust the camera transform while using <code>OrbitControls</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
// move the camera
camera.position.set(1,2,3);

// and/or rotate the camera
camera.rotation.set(0.5, 0, 0);

// then tell the controls to update
controls.update();
</code>
  </pre>
</section>

<p>If you&rsquo;re calling <code>.update</code> in the loop, you don&rsquo;t need to do it manually and you can simply move the camera. If you move the camera <em>without</em> calling <code>.update</code>, weird things will happen, so watch out!</p>
<p>One important thing to note here: when you move the camera, the <code>controls.target</code> does not move. If you have not moved it, it will remain at the center of the scene. When you move the camera to a new position but leave the target unchanged, the camera will not only move but also <em>rotate</em> so that it continues to point at the target. This means that camera movements may not work as you expect when using the controls. Often, you will need to move the camera and the target at the same time to get your desired outcome.</p>
<h4 id="smoothly-transition-to-a-new-camera-position">Smoothly Transition to a New Camera Position</h4>
<p>If you want to smoothly animate the camera to a new position, you will probably need to transition the camera and the target at the same time, and the best place to do this is in the <code>controls.tick</code> method. However, you will need to disable the controls for the duration of the animation, otherwise, if the user attempts to move the camera before the animation has completed, you&rsquo;ll end up with the controls fighting against your animation, often with disastrous results.</p>


<section class="highlight-wrapper"><span class="caption">Disable the controls while animating the camera or target</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">

controls.enabled = false;

</code>
  </pre>
</section>

<h3 id="save-and-restore-a-view-state">Save and Restore a View State</h3>
<p>You can save the current view using <a href="https://threejs.org/docs/index.html#examples/en/controls/OrbitControls.saveState" target="_blank" rel="noopener noreferrer"><code>.saveState</code></a>, and later restore it using <a href="https://threejs.org/docs/index.html#examples/en/controls/OrbitControls.reset" target="_blank" rel="noopener noreferrer"><code>.reset</code></a>:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>controls.js</strong></em>: save and restore state</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.saveState();

// sometime later:
controls.reset();
</code>
  </pre>
</section>

<p>If we call <code>.reset</code> without first calling <code>.saveState</code>, the camera will jump back to the position it was in when we created the controls.</p>
<h3 id="disposing-of-the-controls">Disposing of the Controls</h3>
<p>If you no longer need the controls, you can clean them up using <a href="https://threejs.org/docs/#examples/en/controls/OrbitControls.dispose" target="_blank" rel="noopener noreferrer">.dispose</a>, which will remove all event listeners created by the controls from the canvas.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>controls.js</strong></em>: remove all event listeners from the canvas</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.dispose();
</code>
  </pre>
</section>

<h2 id="rendering-on-demand-with-orbitcontrols">Rendering on Demand with <code>OrbitControls</code></h2>
<p>A couple of chapters ago we set up the <a href="/book/first-steps/animation-loop/">animation loop</a>, a powerful tool that allows us to create beautiful animations with ease. On the other hand, as we discussed at the end of that chapter, <a href="/book/first-steps/animation-loop/#to-loop-or-not-to-loop">the loop does have some downsides</a>, such as increased battery use on mobile devices. As a result, sometime we&rsquo;ll choose to render frames <strong>on demand</strong> instead of generating a constant stream of frames using the loop.</p>
<p>Now that our app has orbit controls, whenever the user interacts with your scene, the controls will move the camera to a new position, and when this occurs you must draw a new frame, otherwise, you won&rsquo;t be able to see that the camera has moved. If you&rsquo;re using the animation loop, that&rsquo;s not a problem. However, if we&rsquo;re rendering on demand we&rsquo;ll have to figure something else out.</p>
<p>Fortunately, <code>OrbitControls</code> provides an easy way to generate new frames whenever the camera moves. The controls have a custom event called <code>change</code> which we can listen for using <a href="/book/appendix/dom-api-reference/#listening-for-events"><code>addEventListener</code></a>. This event will fire whenever a user interaction causes the controls to move the camera.</p>
<p>To use rendering on demand with the orbit control, you must render a frame whenever this event fires:</p>


<section class="highlight-wrapper"><span class="caption">Rendering on demand with <code>OrbitControls</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.addEventListener(&#39;change&#39;, () =&gt; {
  renderer.render(scene, camera);
});
</code>
  </pre>
</section>

<p>To set this up inside <em><strong>World.js</strong></em>, you&rsquo;ll use <code>this.render</code>:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: Rendering on demand with <code>OrbitControls</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.addEventListener(&#39;change&#39;, () =&gt; {
  this.render();
});
</code>
  </pre>
</section>

<p>Next, over in <em><strong>main.js</strong></em>, make sure we&rsquo;re no longer starting the loop. Instead, render the initial frame:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>main.js</strong></em>: render a single frame instead of starting the loop</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="10"
    data-line=""
    data-line-offset="10"
    >
    <code class="highlight language-js match-braces">

// render the inital frame
world.render();

</code>
  </pre>
</section>

<p>If you make these changes in your app, you&rsquo;ll see that this results in a slight problem. When we render the initial frame in <em><strong>main.js</strong></em>, the texture has not yet loaded, so the cube will look black. If we were running the loop, this frame would almost instantly be replaced with a new one after the texture loads, so it might not even be noticeable that the cube was black for a few milliseconds. However, with rendering on demand, we are now only generating new frames when the user interacts with the scene and moves the camera. As soon as you move the controls, sure enough, a new frame will be created and the texture will show up.</p>
<p>As a result, you also need to generate a new frame after the texture has loaded. We won&rsquo;t cover how to do that here, but hopefully, it highlights why rendering on demand is trickier than using the loop. You have to consider all situations where you need a new frame (for example, don&rsquo;t forget that you&rsquo;ll also need to <a href="/book/first-steps/responsive-design/#create-an-onresize-hook">render a frame on resize</a>).</p>
<h2 id="orbitcontrols-configuration"><code>OrbitControls</code> Configuration</h2>
<p>The controls have lots of options that allow us to adjust them to our needs. Most of these are <a href="https://threejs.org/docs/index.html#examples/en/controls/OrbitControls" target="_blank" rel="noopener noreferrer">well explained in the docs</a>, so we won&rsquo;t cover them exhaustively here. The following are some of the most important.</p>
<h3 id="enable-or-disable-the-controls">Enable or Disable the Controls</h3>
<p>We can <a href="https://threejs.org/docs/index.html#examples/en/controls/OrbitControls.enabled" target="_blank" rel="noopener noreferrer">enable or disable the controls</a> entirely:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>controls.js</strong></em>: enable or disable</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.enabled = false;
</code>
  </pre>
</section>

<p>Or, we can disable any of the three modes of control individually:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>controls.js</strong></em>: disable individual modes</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.enableRotate = false;
controls.enableZoom = false;
controls.enablePan = false;
</code>
  </pre>
</section>

<p>By default, you can use the arrow keys to pan the camera. To disable this:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>controls.js</strong></em>: disable keyboard pan controls</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.enableKeys = false;
</code>
  </pre>
</section>

<h3 id="auto-rotate">Auto Rotate</h3>
<p><a href="https://threejs.org/docs/index.html#examples/en/controls/OrbitControls.autoRotate" target="_blank" rel="noopener noreferrer"><code>.autoRotate</code></a> will make the camera automatically rotate around the <code>.target</code>, and <a href="https://threejs.org/docs/#examples/en/controls/OrbitControls.autoRotateSpeed" target="_blank" rel="noopener noreferrer"><code>.autoRotateSpeed</code></a> controls how fast:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>controls.js</strong></em>: enable auto-rotation</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.autoRotate = true;
controls.autoRotateSpeed = 1;
</code>
  </pre>
</section>

<p>As with <code>.enableDamping</code>, you must call <code>controls.update</code> every frame for this to work. Note that <code>.autoRotate</code> will still work if the controls are disabled.</p>
<h3 id="limiting-zoom">Limiting Zoom</h3>
<p>We can limit how far the controls will zoom in or out:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>controls.js</strong></em>: limit zoom</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.minDistance = 5;
controls.maxDistance = 20;
</code>
  </pre>
</section>

<p>Make sure <code>minDistance</code> is not smaller than <a href="https://threejs.org/docs/#api/en/cameras/PerspectiveCamera.near" target="_blank" rel="noopener noreferrer">the camera&rsquo;s near clipping plane</a> and <code>maxDistance</code> is not greater than <a href="https://threejs.org/docs/#api/en/cameras/PerspectiveCamera.far" target="_blank" rel="noopener noreferrer">the camera&rsquo;s far clipping plane</a>. Also, <code>minDistance</code> must be smaller than <code>maxDistance</code>.</p>
<h3 id="limiting-rotation">Limiting Rotation</h3>
<p>We can limit the control&rsquo;s rotation, both horizontally (azimuth angle):</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>controls.js</strong></em>: limit horizontal rotation</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.minAzimuthAngle = - Infinity; // default
controls.maxAzimuthAngle = Infinity; // default
</code>
  </pre>
</section>

<p>&hellip; and vertically (polar angle)</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>controls.js</strong></em>: limit vertical rotation</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
controls.minPolarAngle = 0; // default
controls.maxPolarAngle = Math.PI; // default
</code>
  </pre>
</section>

<p>Remember, <a href="/book/first-steps/transformations/#the-unit-of-rotation-is-radians">rotations are specified using radians</a>, not degrees, and $\pi$ radians is equal to $180^{\circ}$.</p>
<h2 id="a-glaring-problem">A Glaring Problem!</h2>
<p>As soon as we rotate the camera using our fancy new orbit controls, we&rsquo;ll see a glaring problem. The camera rotates, but the light is fixed and shines only from one direction. The rear faces of the cube receive no light at all!</p>
<p>In the real world, light bounces and reflects off every surface, so the rear of the cube would be dimly lit. There&rsquo;s nothing in this simple scene aside from the cube, so there&rsquo;s nothing for the light to bounce off.  But, even if there was, performing these calculations is much too expensive for us to do in real-time. In the next chapter, we will look at a technique for overcoming this problem known as <strong>ambient lighting</strong>.</p>
<h2 id="challenges">Challenges</h2>
<aside class="success">
  
    <h3 id="easy">Easy</h3>
<ol>
<li>
<p>Try adjusting the control&rsquo;s <a href="#limiting-zoom">minimum and maximum zoom levels</a>. What happens if you make these two values equal? Or make <code>minDistance</code> greater than <code>maxDistance</code>?</p>
</li>
<li>
<p>Enable <a href="#auto-rotate">auto-rotation</a> and then try adjusting the rotation speed.</p>
</li>
<li>
<p>Try <a href="#enable-or-disable-the-controls">disabling each of the three modes of control</a>, one at a time, and observe the results.</p>
</li>
<li>
<p><a href="#enable-damping-for-added-realism">Adjust the damping speed</a> (<code>.dampingFactor</code>) to get a feel for how damping works. Values greater than 0 and less than 1 work best.</p>
</li>
</ol>

  
</aside>
<aside class="notice">
  
    <h3 id="medium">Medium</h3>
<ol>
<li>
<p>Try adjusting the control&rsquo;s <a href="#limiting-rotation">horizontal and vertical rotation limits</a>. Remember, if you are working in degrees you must convert to radians. Look inside <em><strong>cube.js</strong></em> if you need a reminder of how that works.</p>
</li>
<li>
<p>Add a button (or a click event listener) to the page, and whenever you click the button, move the camera and control&rsquo;s target to a new, random position. Try and constrain the movement so that the cube is always still somewhere on the screen.</p>
</li>
</ol>

  
</aside>
<aside class="warning">
  
    <h3 id="hard">Hard</h3>
<ol>
<li>
<p>Set up <a href="#rendering-on-demand-with-orbitcontrols">rendering on demand</a> while using the controls, including generating a new frame after the texture has loaded, and whenever the scene is resized.</p>
</li>
<li>
<p>Can you make the camera and the control&rsquo;s target animate to a new position over a few seconds? Maybe add a button to the page, and when you click it, play the animation. See what happens when you animate just the camera, or just the target, or what happens when you don&rsquo;t disable the controls while animating. The best place to set up this animation is in the controls module.</p>
</li>
</ol>

  
</aside>
