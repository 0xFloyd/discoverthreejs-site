<h1 id="the-animation-loop">The Animation Loop</h1>







<figure id="scene-792368145" class="inline-scene loading-dots small right"><figcaption>The output from a single call of<br>renderer.render</figcaption></figure>

<script type="module">
  import init from "/static/examples/worlds/inline-scenes/first-steps/static-cube.js";
  init("#scene-792368145");
</script>

<p>Over the last couple of chapters, we&rsquo;ve made amazing progress with our app. We have lights, colors, physically correct rendering, anti-aliasing, automatic-resizing, we know how to move objects around in 3D space, and our code is clean, modular, and well-structured. But our scene is missing one vital ingredient: <strong>movement!</strong></p>
<p>We&rsquo;re using the <code>renderer.render</code> method to draw the scene. This method takes a scene and a camera as input and outputs a single still image to the HTML <code>&lt;canvas&gt;</code> element. The output is the non-moving purple box you can see above.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: drawing a single frame with <code>renderer.render</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="32"
    data-line="34"
    data-line-offset="32"
    >
    <code class="highlight language-js match-braces">
  render() {
    // draw a single frame
    renderer.render(scene, camera);
  }
</code>
  </pre>
</section>








<figure id="scene-452631978" class="inline-scene loading-dots small right"></figure>

<script type="module">
  import init from "/static/examples/worlds/inline-scenes/first-steps/animation-loop.js";
  init("#scene-452631978");
</script>

<p>In this chapter, we&rsquo;ll add a simple rotation animation to the cube. Here&rsquo;s how we&rsquo;ll do it:</p>
<ul>
<li><strong>call <code>renderer.render(...)</code></strong></li>
<li><strong>wait until it&rsquo;s time to draw the next frame</strong></li>
<li><strong>rotate the cube a tiny amount</strong></li>
<li><strong>call <code>renderer.render(...)</code></strong></li>
<li><strong>wait until it&rsquo;s time to draw the next frame</strong></li>
<li><strong>rotate the cube a tiny amount</strong></li>
<li><strong>call <code>renderer.render(...)</code></strong></li>
<li><strong>wait until it&rsquo;s time to draw the next frame</strong></li>
<li><strong>rotate the cube a tiny amount</strong></li>
<li>&hellip;</li>
</ul>
<p>&hellip; and so on in an endless loop called an <strong>animation loop</strong>. Setting up this loop is simple since three.js does all the hard work for us via the <code>renderer.setAnimationLoop</code> method.</p>
<p>We&rsquo;ll also introduce the three.js <code>Clock</code> in this chapter, a simple stopwatch class that we can use to keep animations in sync. We&rsquo;ll be dealing with time values less than one second throughout this chapter, so we&rsquo;ll use milliseconds (ms), which are thousandths of a second.</p>
<p>Once we&rsquo;ve set up the loop, our goal is to generate a steady stream of frames at a rate of sixty frames a second (60FPS), which means we need to call <code>.render</code> approximately once every sixteen milliseconds. In other words, we need to ensure that all of the processing we do in a frame takes less than 16ms (this is sometimes referred to as a <strong>frame budget</strong>). That means we need to update animations, perform any other tasks that need to be calculated across frames (such as physics), <em>and</em> render the frame, in less than sixteen milliseconds on the lowest spec hardware that we intend to support. Over the rest of this chapter, as we set up the loop and create a simple rotating animation for the cube, we&rsquo;ll discuss how best to achieve this.</p>
<h2 id="similarities-with-the-game-loop">Similarities with the Game Loop</h2>
<p>Most game engines use the concept of a <strong>game loop</strong> that runs once per frame and is used to update and render the game. A basic game loop might consist of these four tasks:</p>
<ol>
<li><strong>Get user input</strong></li>
<li><strong>Calculate physics</strong></li>
<li><strong>Update animations</strong></li>
<li><strong>Render a frame</strong></li>
</ol>
<p>Even though three.js is not a game engine and we are calling our loop an <strong>animation loop</strong>, our goals are pretty similar. This means, instead of starting from scratch, we can borrow some tried and trusted ideas from game engine design. The loop we create in this chapter is very simple, but if you later find yourself needing a more complex one, perhaps to update animations and physics at a different rate than you render the scene, you can refer to a <a href="https://gameprogrammingpatterns.com/game-loop.html" target="_blank" rel="noopener noreferrer">book on game development</a> for more info.</p>
<p>Later, we&rsquo;ll make our scene interactive. Fortunately for us, handling user input in the browser is easy thanks to <a href="/book/appendix/dom-api-reference/#listening-for-events"><code>addEventListener</code></a>, so we don&rsquo;t need to handle this task in the loop. Also, we won&rsquo;t be doing any physics calculations for now (although several great physics libraries work with three.js), so we can skip the physics step. Rendering is already covered by <code>renderer.render</code>. That leaves us with two tasks in this chapter: set up the loop itself, and then create a system for updating animations.</p>
<p>We&rsquo;ll set up the loop first to generate a stream of frames, and then we&rsquo;ll set up the animation system.</p>
<h2 id="creating-an-animation-loop-with-threejs">Creating an Animation Loop with three.js</h2>
<h3 id="the-_loopjs_-module">The <em><strong>Loop.js</strong></em> Module</h3>
<p>Open (or create) the <em><strong>systems/Loop.js</strong></em> module and create a new <code>Loop</code> class inside. This class will handle all the looping logic and the animation system. You&rsquo;ll notice that we have imported <code>Clock</code>, which we&rsquo;ll use below to keep animations in sync. Next, since we&rsquo;ll use <code>renderer.render(scene, camera)</code> to generate frames, it&rsquo;s a fair bet we&rsquo;ll need the <code>camera</code>, <code>scene</code>, and <code>renderer</code> within the <code>Loop</code> class, so pass them to the constructor and save them as instance variables. Finally, create <code>.start</code> and <code>.stop</code> methods that we can later use to start/stop the loop.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Loop.js</strong></em>: initial setup</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">

import { Clock } from &#39;three&#39;;

class Loop {
  constructor(camera, scene, renderer) {
    this.camera = camera;
    this.scene = scene;
    this.renderer = renderer;
  }

  start() {}

  stop() {}
}

export { Loop }

</code>
  </pre>
</section>

<p>Over in World, add this new class to the list of imports:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: import the <code>Loop</code> class</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line="8"
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">import { createCamera } from &#39;./components/camera.js&#39;;
import { createCube } from &#39;./components/cube.js&#39;;
import { createLights } from &#39;./components/lights.js&#39;;
import { createScene } from &#39;./components/scene.js&#39;;

import { createRenderer } from &#39;./systems/renderer.js&#39;;
import { Resizer } from &#39;./systems/Resizer.js&#39;;
import { Loop } from &#39;./systems/Loop.js&#39;;
</code>
  </pre>
</section>

<p>Create the loop as a <a href="/book/first-steps/world-app/#set-up-the-camera-renderer-and-scene">module scoped variable</a> like the <code>camera</code>, <code>renderer</code>, and <code>scene</code>, since we don&rsquo;t want it to be accessible from outside the <code>World</code> class:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: create a <code>loop</code> instance</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="10"
    data-line="13,20"
    data-line-offset="10"
    >
    <code class="highlight language-js match-braces">

let camera;
let renderer;
let scene;
let loop;

class World {
  constructor(container) {
    camera = createCamera();
    renderer = createRenderer();
    scene = createScene();
    loop = new Loop(camera, scene, renderer);
    container.append(renderer.domElement);

    ...
  }

</code>
  </pre>
</section>

<p>Finally, add <code>.start</code> and <code>.stop</code> methods to <code>World</code>, which simply call their counterparts in <code>Loop</code>. This is how we&rsquo;ll provide access to the loop from within <em><strong>main.js</strong></em>:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: create the <code>.start</code> and <code>.stop</code> methods</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="33"
    data-line="38-44"
    data-line-offset="33"
    >
    <code class="highlight language-js match-braces">  render() {
    // draw a single frame
    renderer.render(scene, camera);
  }

  start() {
    loop.start();
  }

  stop() {
    loop.stop();
  }
</code>
  </pre>
</section>

<p>Then, over in <em><strong>main.js</strong></em>, switch out <code>world.render</code>:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>main.js</strong></em>: render a single still frame</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="3"
    data-line="10,11"
    data-line-offset="3"
    >
    <code class="highlight language-js match-braces">function main() {
  // Get a reference to the container element
  const container = document.querySelector(&#39;#scene-container&#39;);

  // create a new world
  const world = new World(container);

  // draw the scene
  world.render();
}
</code>
  </pre>
</section>

<p>&hellip; for <code>world.start</code>:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>main.js</strong></em>: start the animation loop</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="3"
    data-line="10,11"
    data-line-offset="3"
    >
    <code class="highlight language-js match-braces">function main() {
  // Get a reference to the container element
  const container = document.querySelector(&#39;#scene-container&#39;);

  // create a new world
  const world = new World(container);

  // start the animation loop
  world.start();
}
</code>
  </pre>
</section>

<p>The scene will go black when you do this, but don&rsquo;t worry. It&rsquo;ll spring back to life again in a few moments once we have finished creating the loop.</p>
<h3 id="creating-the-loop-with-setanimationloop">Creating the Loop with <code>.setAnimationLoop</code></h3>
<p>Now, everything is set up and we can create the loop. As we mentioned above, we don&rsquo;t need to worry about the technicalities of creating an animation loop since three.js provides a method that does everything for us: <a href="https://threejs.org/docs/#api/en/renderers/WebGLRenderer.setAnimationLoop" target="_blank" rel="noopener noreferrer"><code>WebGLRenderer.setAnimationLoop</code></a>.</p>


<section class="highlight-wrapper"><span class="caption">Creating a loop using <code>.setAnimationLoop</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
import { WebGLRenderer } from &#39;three&#39;;

const renderer = new WebGLRenderer();

// start the loop
renderer.setAnimationLoop(() =&gt; {
  renderer.render(scene, camera);
});
</code>
  </pre>
</section>

<p>This will call <code>renderer.render</code> over and over to generate a stream of frames. We can cancel a running loop by passing <code>null</code> as the callback:</p>


<section class="highlight-wrapper"><span class="caption">Stop a running loop</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
// stop the loop
renderer.setAnimationLoop(null);
</code>
  </pre>
</section>

<p>Internally, the loop is created using <a href="/book/appendix/dom-api-reference/#drawing-animation-frames"><code>.requestAnimationFrame</code></a>. This built-in browser method intelligently schedules frames in sync with the refresh rate of your monitor and will smoothly reduce the frame rate if your hardware can&rsquo;t keep up. Since <code>.setAnimationLoop</code> was added fairly recently, older three.js examples and tutorials often use <code>.requestAnimationFrame</code> directly to set up the loop, and it&rsquo;s fairly simple to do it that way. However, with <code>.setAnimationLoop</code> there&rsquo;s a little extra magic to ensure the loop will work in virtual reality and augmented reality environments.</p>
<aside class="success">
  
    <h3 id="virtual-reality-augmented-reality-and-the-animation-loop">Virtual Reality, Augmented Reality, and the Animation Loop</h3>
<p><strong>Web Virtual Reality</strong> (<strong>WebVR</strong>) and <strong>Web Augmented Reality</strong> (<strong>WebAR</strong>) are combined into a unified API called the <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API" target="_blank" rel="noopener noreferrer"><strong>WebXR Device API</strong></a>. Support for these APIs was added to three.js around the start of 2018. If you&rsquo;re fortunate enough to own a virtual reality device, check out the <a href="https://threejs.org/examples/?q=webxr" target="_blank" rel="noopener noreferrer">three.js VR examples here</a>.</p>
<p>At the time of writing this, in 2020, the WebXR API is relatively new and subject to change as development proceeds. By using <code>.setAnimationLoop</code>, we don&rsquo;t need to worry about any of these changes beyond keeping three.js up to date. Also, if you create a scene now and later decide to add VR capability, it will be easy to do so.</p>

  
</aside>
<h3 id="the-loopstart-and-loopstop-methods">The <code>Loop.start</code> and <code>Loop.stop</code> Methods</h3>
<p>Now, we can create the loop. We&rsquo;ll do it in <code>Loop.start</code> using <code>.setAnimationLoop</code>:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Loop.js</strong></em>: create the <code>.start</code> method</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="13"
    data-line=""
    data-line-offset="13"
    >
    <code class="highlight language-js match-braces">  start() {
    this.renderer.setAnimationLoop(() =&gt; {
      // render a frame
      this.renderer.render(this.scene, this.camera);
    });
  }

</code>
  </pre>
</section>

<p>Next, create the counterpart <code>.stop</code> method, passing in <code>null</code> as the callback to stop the loop:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Loop.js</strong></em>: create the <code>.stop</code> method</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="23"
    data-line=""
    data-line-offset="23"
    >
    <code class="highlight language-js match-braces">  stop() {
    this.renderer.setAnimationLoop(null);
  }
</code>
  </pre>
</section>

<p>As soon as you make these changes, your app will start to pump out frames at a rate of around sixty per second (or possibly higher, depending on the refresh rate of your monitor). However, you won&rsquo;t <em>see</em> any difference. Nothing is moving yet, so we are simply drawing the same frame over and over. Our loop now looks like this:</p>
<ul>
<li><strong>call <code>renderer.render(...)</code></strong></li>
<li><strong>wait until it&rsquo;s time to draw the next frame</strong></li>
<li><strong>call <code>renderer.render(...)</code></strong></li>
<li><strong>wait until it&rsquo;s time to draw the next frame</strong></li>
<li><strong>call <code>renderer.render(...)</code></strong></li>
<li><strong>wait until it&rsquo;s time to draw the next frame</strong></li>
<li>&hellip;</li>
</ul>
<p>If you compare that to the loop we described at the start of the chapter, you&rsquo;ll see we are missing a vital step:</p>
<ul>
<li><strong>call <code>renderer.render(...)</code></strong></li>
<li><strong>wait until it&rsquo;s time to draw the next frame</strong></li>
<li><strong>rotate the cube a tiny amount</strong></li>
<li><strong>call <code>renderer.render(...)</code></strong></li>
<li><strong>wait until it&rsquo;s time to draw the next frame</strong></li>
<li><strong>rotate the cube a tiny amount</strong></li>
<li><strong>call <code>renderer.render(...)</code></strong></li>
<li><strong>wait until it&rsquo;s time to draw the next frame</strong></li>
<li><strong>rotate the cube a tiny amount</strong></li>
<li>&hellip;</li>
</ul>
<p>We need some way to adjust the cube&rsquo;s rotation right before we render each frame, and we need to do so in a way that works for any kind of animated object, not just a rotating cube. More generally, our loop should look like this:</p>
<ul>
<li><strong>call <code>renderer.render(...)</code></strong></li>
<li><strong>wait until it&rsquo;s time to draw the next frame</strong></li>
<li><strong>move animations forward one frame</strong></li>
<li><strong>call <code>renderer.render(...)</code></strong></li>
<li><strong>wait until it&rsquo;s time to draw the next frame</strong></li>
<li><strong>move animations forward one frame</strong></li>
<li><strong>call <code>renderer.render(...)</code></strong></li>
<li><strong>wait until it&rsquo;s time to draw the next frame</strong></li>
<li><strong>move animations forward one frame</strong></li>
<li>&hellip;</li>
</ul>
<h3 id="remove-the-onresize-hook">Remove the <code>onResize</code> Hook</h3>
<p>First, let&rsquo;s tidy up. Now that the loop is running, whenever we resize the window a new frame will be produced on the next iteration of the loop. This is fast enough that you won&rsquo;t notice any delay so we don&rsquo;t need to manually redraw the scene on resizing anymore. Remove the <code>resizer.onResize</code> hook from World:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: remove the highlighted lines</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="17"
    data-line="31-33"
    data-line-offset="17"
    >
    <code class="highlight language-js match-braces">

constructor(container) {
  camera = createCamera();
  scene = createScene();
  renderer = createRenderer();
  container.append(renderer.domElement);

  const cube = createCube();
  const light = createLights();

  updatables.push(cube);

  scene.add(cube, light);

  const resizer = new Resizer(container, camera, renderer);
  resizer.onResize = () =&gt; {
    this.render();
  };
}

</code>
  </pre>
</section>

<p>Now, try resizing the scene and notice that it works smoothly. This shows us that the loop is running correctly.</p>
<h2 id="the-animation-system">The Animation System</h2>
<p>Consider a simple game where you explore a map and pick apples. Here are some animated objects you might add to this game:</p>
<ul>
<li>The heroine, who has various animations like walk/run/jump/climb/pick.</li>
<li>Trees with apples. The apples grow over time, and the leaves blow in the wind.</li>
<li>Some scary bees that will try to chase you from the garden.</li>
<li>An interesting environment with objects like water, wind, leaves, and rocks.</li>
<li>Power-ups in the form of rotating cubes that hover above the ground.</li>
</ul>
<p>&hellip; and so on. Each time the loop runs, we want to update all of these animations by moving them forward one frame. Just before we render each frame, we&rsquo;ll make the heroine step forward a tiny bit, we&rsquo;ll make each bee move towards her, we&rsquo;ll make the leaves move, the apples grow, and the powerups rotate, each by a tiny, tiny amount that is almost too small for the eye to see but over time creates a smooth animation.</p>
<h3 id="the-looptick-method">The <code>Loop.tick</code> Method</h3>
<p>To handle all of this, we need a function that <em>updates</em> all the animations, and this function should run once at the start of each frame. However, the word <em>update</em> is already used a lot throughout three.js, so we&rsquo;ll choose the word <em>tick</em> instead. Before we draw each frame, we&rsquo;ll make each animation <em>tick</em> forward one frame.  Add the <code>Loop.tick</code> method at the end of the <code>Loop</code> class, and then call it within the animation loop:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Loop.js</strong></em>: create the <code>.tick</code> method</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="13"
    data-line="16,27-29"
    data-line-offset="13"
    >
    <code class="highlight language-js match-braces">

start() {
  this.renderer.setAnimationLoop(() =&gt; {
    // tell every animated object to tick forward one frame
    this.tick();

    // render a frame
    this.renderer.render(this.scene, this.camera);
  });
}

stop() {
  this.renderer.setAnimationLoop(null);
}

tick() {
  // Code to update animations will go here
}

</code>
  </pre>
</section>

<h3 id="centralized-or-decentralized">Centralized or Decentralized?</h3>
<p>When it comes to implementing this new <code>.tick</code> method, we have to make some design choices. One obvious solution is to create a complicated, centralized update function that controls all of the animated objects in our scene. It might look something like this:</p>


<section class="highlight-wrapper"><span class="caption">A centralized animation system</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="27"
    data-line=""
    data-line-offset="27"
    >
    <code class="highlight language-js match-braces">

tick() {
  if(controls.state.run) {
    character.runAnimation.nextFrame();
  }

  beeA.moveTowards(character.position);
  beeB.moveTowards(character.position);
  beeC.moveTowards(character.position);

  powerupA.rotation.z &#43;= 0.01;
  powerupB.rotation.z &#43;= 0.01;
  powerupC.rotation.z &#43;= 0.01;

  leafA.rotation.y &#43;= 0.01;

  // ... and so on
}

</code>
  </pre>
</section>

<p>Well, you get the picture. This might be ok if we have just a couple of animated objects in our scene, but it&rsquo;s not going to scale well. With fifty or a hundred animated objects, it&rsquo;s going to be downright ugly. It also breaks all kinds of software design principles, since now the <code>Loop</code> class has to have a deep understanding of how each animated object works.</p>
<p>Here&rsquo;s a better idea: we&rsquo;ll define the logic for updating each object <em>on the object itself</em>. Each object will expose that logic using a generic <code>.tick</code> method of its own. Now, the <code>Loop.tick</code> method will be simple. Each frame, we&rsquo;ll loop over a list of animated objects and tell each of them to <code>.tick</code> forward by one frame. It will look something like this:</p>


<section class="highlight-wrapper"><span class="caption">A decentralized animation system</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="23"
    data-line=""
    data-line-offset="23"
    >
    <code class="highlight language-js match-braces">


// somewhere in the Loop class:
this.updatables = [character, beeA, beeB, beeC, powerupA, powerupB, powerupC, leafA, ... ]
...

tick() {
  for(const object of this.updatables) {
    object.tick();
  }
}

</code>
  </pre>
</section>

<p>This is much better. Now, all the <code>Loop</code> class knows is that &lsquo;<em>animated objects have a <code>.tick</code> method</em>&rsquo;. These methods can be as complex or simple as needed for each object. For example, here&rsquo;s what a simple rotating powerup might look like:</p>


<section class="highlight-wrapper"><span class="caption">Creating a rotating powerup with a <code>.tick</code> method</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">

function createPowerup() {
  const geometry = new BoxBufferGeometry(2, 2, 2);
  const material = new MeshStandardMaterial({ color: &#39;purple&#39; });
  const powerup = new Mesh(geometry, material);

  // this method will be called once per frame
  powerup.tick = () =&gt; {
    // increase the powerup&#39;s rotation each frame
    powerup.rotation.z &#43;= 0.05;

  };

  return powerup;
}

</code>
  </pre>
</section>

<p>If you compare this to <em><strong>components/cube.js</strong></em>, you&rsquo;ll see this is quite similar. We just need to add a <code>cube.tick</code> method.</p>
<p>This approach fits better with the modular philosophy we&rsquo;re using to design our application. Instead of having one part of the app grow more and more complicated, we&rsquo;ll break the complexity into small pieces, with each piece of logic defined at the place where it&rsquo;s used. This way, we can design each object as a self-contained entity. <strong>Every object, from the humble spinning cube to the apple picking heroine, will encapsulate its behavior</strong>. This is a powerful concept which we&rsquo;ll build on throughout the book.</p>
<h3 id="loopupdatables"><code>Loop.updatables</code></h3>
<p>For this to work, we need a list of animated objects within the loop class. We&rsquo;ll use a simple array for this purpose, and we&rsquo;ll call this list <code>updatables</code>. Go ahead and create it now.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Loop.js</strong></em>: create a list to hold animated objects</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="6"
    data-line="10"
    data-line-offset="6"
    >
    <code class="highlight language-js match-braces">  constructor(camera, scene, renderer) {
    this.camera = camera;
    this.scene = scene;
    this.renderer = renderer;
    this.updatables = [];
  }
</code>
  </pre>
</section>

<p>Next, within <code>Loop.tick</code>, loop over this list and call <code>.tick</code> on any object within it.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Loop.js</strong></em>: loop over animated objects and call their <code>.tick</code> method</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="27"
    data-line=""
    data-line-offset="27"
    >
    <code class="highlight language-js match-braces">

tick() {
  for (const object of this.updatables) {
    object.tick();
  }
}

</code>
  </pre>
</section>

<p>Take careful note of the fact that <code>Loop.tick</code> will run every frame, which means it will run sixty times per second. It&rsquo;s important to keep the amount of work done here to a minimum, which means that each animated object&rsquo;s <code>.tick</code> method method must be as simple as possible.</p>
<h3 id="the-cubetick-method">The <code>cube.tick</code> Method</h3>
<p>Before we can add <code>cube</code> to the <code>updatables</code> list, it needs a <code>.tick</code> method, so go ahead and create one. This <code>.tick</code> method is where we&rsquo;ll define the logic for rotating the cube.</p>
<p>Each type of animated object will have a different <code>.tick</code> method. In our <a href="#the-animation-system">apple picking game</a>, the heroine&rsquo;s tick method will check whether she is walking, running, jumping, or standing still, and then play a frame from one of those animations, while the apple tree&rsquo;s tick method will check the ripeness of the apples and rustle the leaves, and each of the evil bee&rsquo;s tick methods will check the position of the heroine then move the bee towards her a tiny bit. If she is close enough, the bee will attempt to sting her.</p>
<p>Here, we&rsquo;ll simply update the cube&rsquo;s rotation on the $X$, $Y$, <em>and</em> $Z$ axes by a tiny amount each frame. This will give it a random-looking tumble.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>cube.js</strong></em>: create the <code>.tick</code> method</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="8"
    data-line="16-21"
    data-line-offset="8"
    >
    <code class="highlight language-js match-braces">

function createCube() {
  const geometry = new BoxBufferGeometry(2, 2, 2);
  const material = new MeshStandardMaterial({ color: &#39;purple&#39; });
  const cube = new Mesh(geometry, material);

  cube.rotation.set(-0.5, -0.1, 0.8);

  // this method will be called once per frame
  cube.tick = () =&gt; {
    // increase the cube&#39;s rotation each frame
    cube.rotation.z &#43;= 0.01;
    cube.rotation.x &#43;= 0.01;
    cube.rotation.y &#43;= 0.01;
  };

  return cube;
}

</code>
  </pre>
</section>

<p><strong>Note</strong>: adding a property to an existing class at run-time like this is known as <a href="https://en.wikipedia.org/wiki/Monkey_patch" target="_blank" rel="noopener noreferrer"><em>monkey-patching</em></a> (here, we&rsquo;re adding <code>.tick</code> to an instance of <code>Mesh</code>). It&rsquo;s common practice, and in our simple app won&rsquo;t cause any problems. However, we shouldn&rsquo;t get into the habit of doing this carelessly since in certain situations it can cause performance issues. We&rsquo;ll only allow ourselves to do this here as the alternatives are more complex.</p>
<p>0.01 is a value that gives a fairly slow rotation speed, and we discovered it by trial and error.  <a href="/book/first-steps/transformations/#the-unit-of-rotation-is-radians">Rotations in three.js are measured in radians</a> so internally this value is being interpreted as <em>0.01 radians</em>, which is roughly half a degree. So, we&rsquo;re rotating the cube by about half a degree on each axis every frame. At sixty frames a second, this means our cube will rotate $60 \times 0.5 = 30 ^{\circ}$ each second, or one full rotation around each of the $X$, $Y$ and $Z$ axes approximately every twelve seconds.</p>
<h4 id="add-the-cube-to-loopupdatables">Add the <code>cube</code> to <code>Loop.updatables</code></h4>
<p>Next, over in World, add the cube to the the <code>Loop.updatables</code> list.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: add the cube to <code>Loop.updatables</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="16"
    data-line="26"
    data-line-offset="16"
    >
    <code class="highlight language-js match-braces">  constructor(container) {
    camera = createCamera();
    renderer = createRenderer();
    scene = createScene();
    loop = new Loop(camera, scene, renderer);
    container.append(renderer.domElement);

    const cube = createCube();
    const light = createLights();

    loop.updatables.push(cube);

    scene.add(cube, light);

    const resizer = new Resizer(container, camera, renderer);
  }
</code>
  </pre>
</section>

<p>Right away, the cube should start rotating.</p>
<h2 id="timing-in-the-animation-system">Timing in the Animation System</h2>
<p>Look at this sentence again: <em><strong>at sixty frames a second</strong>, this means our cube will rotate $60 \times 0.5 = 30 ^{\circ}$ each second, or one full rotation around each of the $X$, $Y$ and $Z$ axes approximately every twelve seconds</em>. But, what if our app is <em>not</em> running at sixty frames a second? If it&rsquo;s running at slower than 60FPS the animation will run slowly, while if it runs faster, the animation will run faster. In other words, the speed of our animation depends on the device it&rsquo;s being viewed on. Not good. To understand how to fix this, we need to take a deeper look at what we mean by the word <em>frame</em>.</p>
<h3 id="fixed-and-dynamic-frames">Fixed and Dynamic Frames</h3>
<p>There&rsquo;s an important distinction between the kind of frames we are talking about in this chapter and the kind of frames that make up television shows or movies. <strong>Frame rates in film are <em>fixed</em></strong>. Movies are usually shot at 24 frames per second (FPS), while the standard for television shows is 30FPS, although some newer shows may be filmed at 60FPS. Whatever frame rate is chosen, that rate won&rsquo;t change for the entire duration of the movie or show.</p>
<p>However, <strong>our animation loop doesn&rsquo;t generate frames at a fixed rate</strong>. The loop will attempt to render frames at the hardware-defined refresh rate of your screen (behind the scenes the browser is using <code>.requestAnimationFrame</code> to do this). At the time of writing, most screens have a 60Hz refresh rate, but this value can be as high as 240Hz on new screens, while in VR it will be at least 90Hz. This means, on a 60Hz screen, the <strong>target frame rate</strong> is 60FPS, on a 90Hz screen, the target frame rate is 90FPS, and so on.</p>
<p>However, we might not succeed in generating frames that quickly. If the device your app is running on is not be powerful enough to reach the target frame rate, the animation loop will run more slowly. Even on fast hardware, your app will have to share computing resources with other applications, and there may not always be enough to go around. In each of these cases, the animation loop will generate frames at a lower rate, and this rate may fluctuate from one moment to the next depending on many factors. This is called a <strong><em>variable frame rate</em></strong>.</p>
<p>That means, as we have currently set up the animation of our cube, it will rotate more slowly on an old, slow device, while on fancy new 240Hz gaming monitor it will go into hyper-speed. $240 = 4\times60$, meaning the cube will rotate at four times the desired speed!</p>
<p>To prevent this, <strong>we need to decouple animation speed from frame rate</strong>. Here&rsquo;s how we&rsquo;ll do it: <strong>when we tell an object to <code>.tick</code> forward a frame, we&rsquo;ll scale the size of the movement by how long the previous frame took</strong>. This way, as the frame rate varies, we&rsquo;ll constantly adjust the size of each <code>.tick</code> so that the animation remains smooth. Our adjustments will always be one frame behind, but the frames are generated so quickly this won&rsquo;t be visible to the user. This way, animations will run at the same speed on all devices.</p>
<h3 id="measuring-time-across-frames">Measuring Time Across Frames</h3>
<p>This is where the <code>Clock</code> class comes in. We&rsquo;ll use <a href="https://threejs.org/docs/#api/en/core/Clock.getDelta" target="_blank" rel="noopener noreferrer"><code>Clock.getDelta</code></a> to measure how long the previous frame took.</p>


<section class="highlight-wrapper"><span class="caption">The <code>Clock.getDelta</code> method</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
import { Clock } from &#39;three&#39;;

const clock = new Clock();

const delta = clock.getDelta();
</code>
  </pre>
</section>

<p><strong><code>.getDelta</code> tells us how much time has passed since the last time we called <code>.getDelta</code></strong>. If we call it once, and only once, at the start of each frame, it will tell us how long the previous frame took. <strong>Note: if you call it <code>.getDelta</code> more than once per frame, subsequent calls will measure close to zero.</strong> Only call <code>.getDelta</code> once at the very start of a frame!</p>
<aside class="notice">
  
    <h4 id="delta">$Δ$ (Delta)</h4>
<p>Delta is a Greek letter, uppercase $Δ$, lowercase $δ$.</p>
<p>The $Δ$ symbol is often used to denote a change in some quantity. Here, <code>Clock.getDelta</code> tells us the rate of change of time.</p>

  
</aside>
<h3 id="create-a-clock">Create a <code>clock</code></h3>
<p>Over in Loop, create a module scoped <code>clock</code> instance at the top of the file.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Loop.js</strong></em>: create the <code>clock</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line="3"
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">import { Clock } from &#39;three&#39;;

const clock = new Clock();

class Loop {
  ...</code>
  </pre>
</section>

<h3 id="call-getdelta-at-the-start-of-each-frame">Call <code>.getDelta</code> at the Start of Each Frame</h3>
<p>Next, we&rsquo;ll call <code>.getDelta</code> at the start of <code>Loop.tick</code>, saving the result in a variable called <code>delta</code> which we&rsquo;ll then pass into the <code>.tick</code> method of each animated object.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Loop.js</strong></em>: pass time deltas to animated objects</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="27"
    data-line="29,32"
    data-line-offset="27"
    >
    <code class="highlight language-js match-braces">  tick() {
    // only call the getDelta function once per frame!
    const delta = clock.getDelta();

    for (const object of this.updatables) {
      object.tick(delta);
    }
  }
</code>
  </pre>
</section>

<aside class="success">
  
    <h3 id="frame-rates-are-never-perfectly-steady">Frame Rates Are Never Perfectly Steady</h3>
<p>In the inline code editor, we&rsquo;ve added a log statement:</p>
<section class="highlight-wrapper"><span class="caption"><em><strong>Loop.js</strong></em>: Log the elapsed time in milliseconds</span>
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="31"
    data-line=""
    data-line-offset="31"
    >
    <code class="highlight language-js match-braces">    // console.log(
    //   `The last frame rendered in ${delta * 1000} milliseconds`,
    // );
</code>
  </pre>
</section>
<p><code>delta</code> is in seconds, so we multiplied it by one thousand to convert to milliseconds. These lines are commented out to avoid filling the console with hundreds of logs statement, but if you remove the <code>//</code> characters, and open the console by pressing F12, you&rsquo;ll see a rapidly updating list of logs telling you how long each frame took to render. If you are viewing this page on a monitor with a refresh rate of 60Hz, it&rsquo;ll look something like this:</p>
<section class="highlight-wrapper"><span class="caption">Frame times logged to the console</span>
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-bash match-braces">
The last frame rendered in $17.40000000083819$ milliseconds
The last frame rendered in $15.710000006947666$ milliseconds
The last frame rendered in $16.574999986914918$ milliseconds
...
</code>
  </pre>
</section>
<p>Even with a powerful GPU and a scene as simple as this single cube, we won&rsquo;t achieve exactly sixty frames per second. Some frames render a little fast, and others render a little slow. This is normal. Part of the reason for this is that, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now#Reduced_time_precision" target="_blank" rel="noopener noreferrer">for security reasons</a> browsers add around a millisecond of jitter to the result of <code>.getDelta</code>.</p>

  
</aside>
<h3 id="scale-the-cubes-rotation-by-delta">Scale the Cube&rsquo;s Rotation by <code>delta</code></h3>
<p>Scaling movements by <code>delta</code> is easy. We simply decide how much we want to move an object in one second, and then multiply that value by <code>delta</code> within the objects <code>.tick</code> method. In  <code>cube.tick</code>, we found a value that resulted in the cube rotating approximately thirty degrees a second <em>at 60FPS</em>.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>cube.js</strong></em>: the unscaled tick method</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="18"
    data-line=""
    data-line-offset="18"
    >
    <code class="highlight language-js match-braces">

cube.tick = () =&gt; {
  // increase the cube&#39;s rotation each frame
  cube.rotation.z &#43;= 0.01;
  cube.rotation.x &#43;= 0.01;
  cube.rotation.y &#43;= 0.01;
};

</code>
  </pre>
</section>

<p>Now, we&rsquo;ll fix that so the cube rotates thirty degrees per second at <em>any</em> FPS. First, we need to convert thirty degrees to radians, and for that, we&rsquo;ll use <a href="/book/first-steps/transformations/#the-unit-of-rotation-is-radians"><code>MathUtils.degToRad</code></a> method (refer back to the transformations chapter if you need a reminder of how that works):</p>


<section class="highlight-wrapper"><span class="caption">Converting degrees to radians</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
import { MathUtils } from &#39;three&#39;;

const radiansPerSecond = MathUtils.degToRad(30);
</code>
  </pre>
</section>

<p>Next, we&rsquo;ll scale <code>radiansPerSecond</code> by <code>delta</code> each frame.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>cube.js</strong></em>: the updated tick method, now scaling by <code>delta</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">

cube.tick = (delta) =&gt; {
  // increase the cube&#39;s rotation each frame
  cube.rotation.z &#43;= radiansPerSecond * delta;
  cube.rotation.x &#43;= radiansPerSecond * delta;
  cube.rotation.y &#43;= radiansPerSecond * delta;
};

</code>
  </pre>
</section>

<p>Putting all that together, here&rsquo;s our final <em><strong>cube.js</strong></em> module:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>cube.js</strong></em>: final code</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line="3,15,18-23"
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">import {
  BoxBufferGeometry,
  MathUtils,
  Mesh,
  MeshStandardMaterial,
} from &#39;three&#39;;

function createCube() {
  const geometry = new BoxBufferGeometry(2, 2, 2);
  const material = new MeshStandardMaterial({ color: &#39;purple&#39; });
  const cube = new Mesh(geometry, material);

  cube.rotation.set(-0.5, -0.1, 0.8);

  const radiansPerSecond = MathUtils.degToRad(30);

  // this method will be called once per frame
  cube.tick = (delta) =&gt; {
    // increase the cube&#39;s rotation each frame
    cube.rotation.z &#43;= radiansPerSecond * delta;
    cube.rotation.x &#43;= radiansPerSecond * delta;
    cube.rotation.y &#43;= radiansPerSecond * delta;
  };

  return cube;
}
</code>
  </pre>
</section>








<figure id="scene-498613752" class="inline-scene loading-dots small right"></figure>

<script type="module">
  import init from "/static/examples/worlds/inline-scenes/first-steps/animation-loop-duplicate.js";
  init("#scene-498613752");
</script>

<p>Now, once again the cube will be rotating thirty degrees per second around each axis, but with an important difference: the animation will now play at the same speed no matter where we run it, whether on a VR rig running at 90FPS, or a ten-year-old smartphone that can barely crank out 10FPS, or some future system from the year 3000 that runs at a billion FPS. <strong>The frame rate may change, but the animation speed will not</strong>.</p>
<p>With this change, <strong>we have successfully decoupled animation speed from frame rate.</strong></p>
<h2 id="to-loop-or-not-to-loop">To Loop or Not to Loop</h2>
<p>Now that we&rsquo;ve started the loop, <code>.render</code> is being called over and over, creating a steady stream of frames, and before we render each frame, we&rsquo;re rotating the cube by a tiny amount. As long as the frames are being generated with sufficient speed (around 12FPS or above), and the difference between successive frames is small enough, we&rsquo;ll perceive this as an animation.</p>
<p>The animation loop will be the driving force of many apps. This loop, when combined with the idea of encapsulating the animation logic in each object&rsquo;s <code>.tick</code> method, is a powerful tool that we&rsquo;ll continue to explore and build on throughout the book. Later, we&rsquo;ll use the loop to drive behavior that is much more complex and interesting than our simple rotating cube, either <a href="https://threejs.org/examples/webgl_buffergeometry_instancing.html" target="_blank" rel="noopener noreferrer">created in our code</a> or <a href="https://threejs.org/examples/webgl_loader_fbx.html" target="_blank" rel="noopener noreferrer">loaded from an external application</a>.</p>
<div class="fig-comparison">
  <figure class="">
  <iframe title="An animation created in code" width="100%" height="500px" src="https://threejs.org/examples/webgl_buffergeometry_instancing.html" importance="low" loading="lazy" sandbox="allow-scripts"></iframe><figcaption>An animation created in code</figcaption></figure>
  <figure class="">
  <iframe title="An animation created in an external application" width="100%" height="500px" src="https://threejs.org/examples/webgl_loader_fbx.html" importance="low" loading="lazy" sandbox="allow-scripts"></iframe><figcaption>An animation created in an external application</figcaption></figure>
</div>
<p>Animations like these are beautiful. However, they come at a cost, which will probably be obvious to you right now if you are viewing this on a low-powered device. As you chase the goal of sixty frames per second, you must work hard to keep the loop running fast. This is one place in your app where constant vigilance, profiling, and optimization is a necessity.</p>
<p>Not all scenes have animation though. Some scenes update only occasionally, for example, only during user interaction. A common example of this is a product display app. Such apps are used to display a 3D product such as a shoe or milk bottle that the user can rotate or zoom to get a better look. In this type of scene, whenever the user is <em>not</em> interacting, the scene will remain unchanged between frames. Here&rsquo;s another example of a scene without an animation loop.</p>
<figure class="">
  <iframe title="No animation loop doesn&#39;t mean no movement!" width="100%" height="500px" src="https://threejs.org/examples/webgl_decals.html" importance="low" loading="lazy" sandbox="allow-scripts"></iframe><figcaption>No animation loop doesn&rsquo;t mean no movement!</figcaption></figure>
<p>Running the loop for an app like this would be a waste. This will be especially noticeable on mobile devices, where the constant GPU and CPU churn of the loop will drain the battery. As a result, you should only use the loop when you need to.</p>
<p><code>World.render</code> and <code>World.start</code> give us two ways of producing frames. For apps with constant animation, we&rsquo;ll use <code>.start</code> to run a loop, and for apps that update occasionally, we&rsquo;ll call <code>.render</code> whenever a new frame is needed. We&rsquo;ll refer to the second technique as <strong><em>rendering on demand</em></strong>.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>main.js</strong></em>: two ways of producing frames</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const world = new World();

// produce a single frame (render on demand)
world.render();

// start the loop (produce a stream of frames)
world.start();
</code>
  </pre>
</section>

<p>Rendering on demand may reduce battery use, but on the other hand, using the loop is simpler. Instead of thinking about where and when you need to draw frames, you simply churn out a constant, steady supply, and for this reason, most of the examples in this book will use the loop. However, this is not an endorsement of the loop over rendering on demand. It&rsquo;s up to you to decide which method is appropriate for your app.</p>
<p>Next up, we&rsquo;ll see how to make our materials more interesting using textures.</p>
<h2 id="challenges">Challenges</h2>
<aside class="success">
  
    <h3 id="easy">Easy</h3>
<ol>
<li>
<p>Play with the animation speed. Make the cube perform one rotation every hundred seconds, then one rotation every single second.</p>
</li>
<li>
<p>You can animate anything, not just rotations. Try animating some other properties of the mesh.</p>
</li>
</ol>

  
</aside>
<aside class="notice">
  
    <h3 id="medium">Medium</h3>
<ol>
<li>
<p>Add a <code>.tick</code> method to the camera, then make it zoom out slowly. Try zooming out at around one meter per second.</p>
</li>
<li>
<p>Add a <code>.tick</code> method to the light, and animate any of the <code>light.position.x</code>, <code>.y</code>, or <code>.z</code> parameters.</p>
</li>
<li>
<p>Add a <code>click</code> event listener (or, if you want to get fancy, a button) that starts and stops the animation loop. Do this in <em><strong>main.js</strong></em> using <code>World.start</code> and <code>World.stop</code>.</p>
</li>
</ol>
<p>Don&rsquo;t forget to add the camera and light to the <code>updatables</code> list! To zoom out, increase <code>camera.position.z</code>.</p>

  
</aside>
<aside class="warning">
  
    <h3 id="hard">Hard</h3>
<p>Rotation is an easy property to animate since rotations go round in circles. When we reach $360^\circ$ on any axis, we come back to where we started. This means we can infinitely increase the rotation and the result is a nice looking animation. If we do the same with position, or scaling, the object being animated will quickly vanish from our screens. However, we can create cyclical animations of other properties using <a href="/book/appendix/javascript-reference/#the-modulo-operator">the modulo operator <code>%</code></a>.</p>
<ol>
<li>
<p>Animate the <code>.position</code> of the cube, camera, or light, using the modulo operator. Make the camera zoom out by ten meters repeatedly. Make the cube animate from the left to the right of the screen over and over again.</p>
</li>
<li>
<p>Make the camera zoom out by ten meters, then reverse direction to zoom in again. Animate the cube from left to right across the screen, then, when it reaches the right edge of the screen (roughly), have it reverse direction and move back to the starting point.</p>
</li>
</ol>

  
</aside>
