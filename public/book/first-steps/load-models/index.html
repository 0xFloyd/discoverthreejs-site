<h1 id="load-3d-models-in-gltf-format">Load 3D Models in glTF Format</h1>







<figure id="scene-845927613" class="inline-scene loading-dots round"></figure>

<script type="module">
  import init from "/static/examples/worlds/inline-scenes/first-steps/birds-animated.js";
  init("#scene-845927613");
</script>

<p>In the last chapter, we created a simple toy train model using some of the built-in three.js geometries, and it quickly became clear that it would be hard to build anything complex or organic using just these. To create beautiful 3D models, a sophisticated <a href="https://en.wikipedia.org/wiki/3D_modeling" target="_blank" rel="noopener noreferrer">modeling program</a> is required. You can use three.js to build any kind of 3D application, however, building a modeling app from scratch would be a huge amount of work. A much simpler solution is to use an existing program and export your work for use in three.js&hellip;  or, cheat, and download any of the millions of amazing models and other scene assets that are available for free in many places around the web.</p>
<p>In this chapter, we&rsquo;ll show you how to load some models that were created in <a href="https://www.blender.org/" target="_blank" rel="noopener noreferrer">Blender</a>, an open-source 3D graphics application that can be used for modeling, scene building, material creation, animation authoring, and more. Once you have created a model in Blender, you can export your work using a 3D format such as glTF, then use the <a href="https://threejs.org/docs/#examples/en/loaders/GLTFLoader" target="_blank" rel="noopener noreferrer"><code>GLTFLoader</code> plugin</a> to bring the model into three.js.</p>
<h2 id="the-best-way-to-send-3d-assets-over-the-web-gltf">The Best Way to Send 3D Assets Over the Web: glTF</h2>
<p>There have been many attempts at creating a standard 3D <strong>asset exchange format</strong> over the last thirty years or so. <a href="https://threejs.org/examples/webgl_loader_fbx.html" target="_blank" rel="noopener noreferrer">FBX</a>, <a href="https://threejs.org/examples/#webgl_loader_obj_mtl" target="_blank" rel="noopener noreferrer">OBJ (Wavefront)</a> and <a href="https://threejs.org/examples/?q=collada#webgl_loader_collada_skinning" target="_blank" rel="noopener noreferrer">DAE (Collada)</a> formats were the most popular of these until recently, although they all have problems that prevented their widespread adoption. For example, OBJ doesn&rsquo;t support animation, FBX is a closed format that belongs to Autodesk, and the Collada spec is overly complex, resulting in large files that are difficult to load.</p>
<p>However, recently, a newcomer called <strong>glTF</strong> has become the de facto standard format for exchanging 3D assets on the web. <a href="https://www.khronos.org/gltf/" target="_blank" rel="noopener noreferrer">glTF</a> (<strong>GL Transmission Format</strong>), sometimes referred to as the <em>JPEG of 3D</em>, was created by the <a href="https://www.khronos.org/" target="_blank" rel="noopener noreferrer">Kronos Group</a>, the same people who are in charge of WebGL, OpenGL, and a whole host of other graphics APIs. Originally released in 2017, glTF is now the best format for exchanging 3D assets on the web, and in many other fields. <strong>In this book, we&rsquo;ll always use glTF, and if possible, you should do the same</strong>. It&rsquo;s designed for sharing models on the web, so the file size is as small as possible and your models will load quickly.</p>
<p>However, since glTF is relatively new, your favorite application might not have an exporter yet. In that case, you can convert your models to glTF before using them, or use another loader such as the <code>FBXLoader</code> or <code>OBJLoader</code>. All three.js loaders work the same way, so if you do need to use another loader, everything from this chapter will still apply, with only minor differences.</p>
<blockquote>
<p>Whenever we mention glTF, we mean <em>glTF Version 2</em>. The original <em>glTF Version 1</em> never found widespread use and is no longer supported by three.js</p>
</blockquote>
<p>glTF files can contain models, animations, geometries, materials, lights, cameras, or even entire scenes. This means you can create an entire scene in an external program then load it into three.js.</p>
<figure class="">
  <iframe title="This entire scene fits in a single `.glb` file." width="100%" height="500px" src="https://threejs.org/examples/webgl_animation_keyframes.html" importance="low" loading="lazy" sandbox="allow-scripts"></iframe><figcaption>This entire scene fits in a single <em><strong>.glb</strong></em> file.</figcaption></figure>
<h3 id="types-of-gltf-files">Types of glTF Files</h3>
<p>glTF files come in standard and binary form. These have different extensions:</p>
<ul>
<li><strong>Standard <em>.gltf</em> files are uncompressed and may come with an extra <em>.bin</em> data file.</strong></li>
<li><strong>Binary <em>.glb</em> files include all data in one single file.</strong></li>
</ul>
<p>Both standard and binary glTF files may contain textures embedded in the file or may reference external textures. Since binary <em><strong>.glb</strong></em> files are considerably smaller, it&rsquo;s best to use this type. On the other hand, uncompressed <em><strong>.gltf</strong></em> are easily readable in a text editor, so they may be useful for debugging purposes.</p>
<h3 id="free-gltf-files-on-the-threejs-repo">Free glTF Files on the three.js Repo</h3>
<p>There are lots of <a href="https://github.com/mrdoob/three.js/tree/master/examples/models/gltf" target="_blank" rel="noopener noreferrer">free glTF models available on the three.js repo</a>, and amongst these are three simple and beautiful models of a <a href="https://github.com/mrdoob/three.js/blob/dev/examples/models/gltf/Parrot.glb" target="_blank" rel="noopener noreferrer">parrot</a>, a <a href="https://github.com/mrdoob/three.js/blob/dev/examples/models/gltf/Flamingo.glb" target="_blank" rel="noopener noreferrer">flamingo</a>, and a <a href="https://github.com/mrdoob/three.js/blob/dev/examples/models/gltf/Stork.glb" target="_blank" rel="noopener noreferrer">stork</a>, created by the talented people at <a href="http://mirada.com/" target="_blank" rel="noopener noreferrer">mirada.com</a>. These three models are <a href="https://en.wikipedia.org/wiki/Low_poly" target="_blank" rel="noopener noreferrer"><strong>low poly</strong></a>, meaning they&rsquo;ll run on even the most low-power of mobile devices, and they are even animated.</p>
<p>You can find these three files in the editor, in the <em><strong>assets/models/</strong></em> folder. In this chapter, we&rsquo;ll load <strong><em>Parrot.glb</em></strong>, <strong><em>Flamingo.glb</em></strong>, and <strong><em>Stork.glb</em></strong> and then add the bird-shaped meshes each file contains to our scene. In the next chapter, we&rsquo;ll show you how to play the flying animation that is included with each bird.</p>
<p>If you&rsquo;re working locally rather than using the inline code editor, <a href="/book/introduction/prerequisites/#a-web-server">you&rsquo;ll need to set up a webserver</a>. Otherwise, due to browser security restrictions, you won&rsquo;t be able to load these files from your hard drive.</p>
<aside class="notice">
  
    <h2 id="asynchronous-javascript">Asynchronous JavaScript</h2>
<p>Whenever we load a model over the internet, we need to do so in a manner that ensures our app continues to run smoothly while the model is loading, and which can also gracefully handle failure if there is a network error. There are several ways to solve this problem using JavaScript, and there&rsquo;s an entire chapter of the appendices dedicated to this subject.</p>
<p>In this chapter, we&rsquo;ll use <strong>async functions</strong> to load the models, and we&rsquo;re going to assume that you have at least some familiarity with these. If these are new to you, or you need a refresher, head over to <a href="/book/appendix/asynchronous-javascript/">A.5: Asynchronous JavaScript</a>.</p>

  
</aside>
<h2 id="gltf-loader">The <code>GLTFLoader</code> Plugin</h2>
<p>To load glTF files, first, you need to add <a href="https://threejs.org/docs/#examples/en/loaders/GLTFLoader" target="_blank" rel="noopener noreferrer">the <code>GLTFLoader</code> plugin</a> to your app. This works the same way as adding the <a href="/book/first-steps/camera-controls/#importing-plugins"><code>OrbitControls</code> plugin</a>. You can find the loader in <a href="https://github.com/mrdoob/three.js/blob/dev/examples/jsm/loaders/GLTFLoader.js" target="_blank" rel="noopener noreferrer"><em><strong>examples/jsm/loaders/GLTFLoader.js</strong></em></a> on the repo, and we have also included this file in the editor. Go ahead and locate the file now.</p>
<p>Importing and creating an instance of the loader works like this:</p>


<section class="highlight-wrapper"><span class="caption">Import and create an instance of the <code>GLTFLoader</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
import { GLTFLoader } from &#39;three/examples/jsm/loaders/GLTFLoader.js&#39;

const loader = new GLTFLoader();
</code>
  </pre>
</section>

<p>You can use one instance of the loader to load any number of glTF files.</p>
<h3 id="the-load-and-loadasync-methods">The <code>.load</code> and <code>.loadAsync</code> Methods</h3>
<p>All three.js loaders have two methods for loading files: the old callback-based <a href="https://threejs.org/docs/#examples/en/loaders/GLTFLoader.load" target="_blank" rel="noopener noreferrer"><code>.load</code></a> method, and the newer Promise based <code>.loadAsync</code> method. Again, refer to chapter <a href="/book/appendix/asynchronous-javascript/">A.5</a> where we cover the difference between these two approaches in detail. Promises allow us to use async functions, which in turn results in much cleaner code, so throughout this book, we will always use <code>.loadAsync</code>.</p>


<section class="highlight-wrapper"><span class="caption"><code>GLTFLoader.loadAsync</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const loader = new GLTFLoader();

const loadedData = await loader.loadAsync(&#39;path/to/yourModel.glb&#39;);
</code>
  </pre>
</section>

<h2 id="set-up-_mainjs_-and-_worldjs_-to-handle-asyncawait">Set Up <em><strong>Main.js</strong></em> and <em><strong>World.js</strong></em> to Handle Async/Await</h2>
<p>The <code>await</code> keyword means &ldquo;wait here until the model has loaded&rdquo;. If you have previously dealt with loading models using callbacks or Promises, then <code>await</code> will seem almost magical in its simplicity. However, we need to make a few adjustments to our code before we can use it since we can only use <code>await</code> inside a function that has been marked as <code>async</code>:</p>


<section class="highlight-wrapper"><span class="caption">You can only use <code>await</code> inside an <code>async</code> function</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
async function loadingSuccess() {
  // inside an async function: OK!
  await loader.loadAsync(&#39;yourModel.glb&#39;);
}

function loadingFail() {
  // not inside an async function: ERROR!
  await loader.loadAsync(&#39;yourModel.glb&#39;);
}
</code>
  </pre>
</section>

<p>Another issue is that we cannot mark a constructor as async. A common solution to this is to create a separate <code>.init</code> method.</p>


<section class="highlight-wrapper"><span class="caption">The constructor of a class cannot be <code>async</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
class Foobazzer {
  constructor() {
    // constructor cannot be async: ERROR!
    await loader.loadAsync(&#39;yourModel.glb&#39;);
  }

  async init() {
    // inside an async function: OK!
    await loader.loadAsync(&#39;yourModel.glb&#39;)
  }
}
</code>
  </pre>
</section>

<p>This way, the constructor can handle the synchronous setup of the class, as usual, and then the init method will take over for asynchronous setup. We will use this approach, so we need to create a new <code>World.init</code> method.</p>


<section class="highlight-wrapper"><span class="caption">We will create a new <code>World.init</code> method to handle asynchronous setup</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">

class World {
  constructor() {
    // synchronous setup here
    // create camera, renderer, scene, etc.
  }

  async init() {
    // asynchronous setup here
    // load bird models
  }
}

</code>
  </pre>
</section>

<p>Go ahead and add an empty <code>.init</code> method to World now, and make sure you mark it <code>async</code>. Splitting the setup into synchronous and asynchronous stages like this gives us full control over the setup of our app. In the synchronous stage, we will create everything that doesn&rsquo;t rely on loaded assets, and in the asynchronous stage, we&rsquo;ll create everything that does.</p>
<h3 id="mark-the-main-function-as-async">Mark the <code>main</code> Function as Async</h3>
<p>Over in <em><strong>main.js</strong></em>, first, we must also mark the main function as async. This is required so that we can call the async <code>World.init</code> method.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>main.js</strong></em>: mark main as <code>async</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="3"
    data-line="3"
    data-line-offset="3"
    >
    <code class="highlight language-js match-braces">async function main() {
</code>
  </pre>
</section>

<p>Now we can call both stages of setting up the World app. First, the synchronous constructor, as usual, then the new <code>.init</code> method to handle asynchronous tasks.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>main.js</strong></em>: call both synchronous and asynchronous stages of World setup</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="3"
    data-line="8,11"
    data-line-offset="3"
    >
    <code class="highlight language-js match-braces">async function main() {
  // Get a reference to the container element
  const container = document.querySelector(&#39;#scene-container&#39;);

  // create a new world
  const world = new World(container);

  // complete async tasks
  await world.init();

  // start the animation loop
  world.start();
}
</code>
  </pre>
</section>

<h3 id="catch-errors">Catch Errors</h3>
<p>No method of loading files is complete unless we can also handle any errors that occur. Errors can be as simple as a typo in the file name, or something more complex like a network error. Fortunately, with async functions, error handling is also simple. At the bottom of <em><strong>main.js</strong></em>, replace this line:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>main.js</strong></em>: calling the main() function</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="17"
    data-line=""
    data-line-offset="17"
    >
    <code class="highlight language-js match-braces">
main();
</code>
  </pre>
</section>

<p>&hellip; with:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>main.js</strong></em>: add a catch method to handle errors</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="17"
    data-line=""
    data-line-offset="17"
    >
    <code class="highlight language-js match-braces">main().catch((err) =&gt; {
  console.error(err);
});
</code>
  </pre>
</section>

<p>Now any errors will be logged to the console. In a real app, you might want to do more sophisticated error handling, such as displaying a message to the user to let them know that something went wrong. However, while we are in development mode, the most important thing is that all errors are logged to the console where we can see them.</p>
<h2 id="create-the-_birdsjs_-module">Create the <em><strong>birds.js</strong></em> Module</h2>
<p>Now everything is set up and we can go ahead and load our first model. Open (or create) the <em><strong>components/birds/birds.js</strong></em> module. Start by importing the <code>GLTFLoader</code>, then create an async <code>loadBirds</code> function. Inside the function, create an instance of the loader, and finally, export the function at the bottom of the file:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>birds/birds.js</strong></em>: initial structure</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
import { GLTFLoader } from &#39;three/examples/jsm/loaders/GLTFLoader.js&#39;;

async function loadBirds() {
  const loader = new GLTFLoader();
}

export { loadBirds };
</code>
  </pre>
</section>

<p>The structure of this new module should be familiar to you since it&rsquo;s the same as nearly <a href="/book/first-steps/world-app/#systems-and-components">every other component we have created so far</a>. The only difference is the <code>async</code> keyword.</p>
<p>Over in World, update the list of imports:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: import components</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line="1"
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">import { loadBirds } from &#39;./components/birds/birds.js&#39;;
import { createCamera } from &#39;./components/camera.js&#39;;
import { createLights } from &#39;./components/lights.js&#39;;
import { createScene } from &#39;./components/scene.js&#39;;
</code>
  </pre>
</section>

<h3 id="load-the-parrot">Load the Parrot</h3>
<p>Now, we&rsquo;re ready to load the <em><strong>Parrot.glb</strong></em> file using <code>.loadAsync</code>. Once you have done so, log the loaded data to the console:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>birds.js</strong></em>: load the Parrot</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="3"
    data-line=""
    data-line-offset="3"
    >
    <code class="highlight language-js match-braces">
async function loadBirds() {
  const loader = new GLTFLoader();

  const parrotData = await loader.loadAsync(&#39;/assets/models/Parrot.glb&#39;);

  console.log(&#39;Squaaawk!&#39;, parrotData);
}
</code>
  </pre>
</section>

<p>Next, call the <code>loadBirds</code> in <code>World.init</code>:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: load the birds!</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="36"
    data-line=""
    data-line-offset="36"
    >
    <code class="highlight language-js match-braces">
async init() {
  await loadBirds();
}
</code>
  </pre>
</section>

<h2 id="returned-gltf-data">Data Returned by the <code>GLTFLoader</code></h2>
<p>We need to take a deeper look at the data we have just loaded before we can add the model to our scene, so for now we&rsquo;ve simply logged the data to the console. Open up the browser console (press F12). You should see the word <em>Squaaawk!</em> followed by an Object containing the loaded data. This Object contains meshes, animations, cameras, and other data from the file:</p>


<section class="highlight-wrapper"><span class="caption">Data return by the <code>GLTFLoader</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
{
  animations: [AnimationClip]
  asset: {generator: &#34;Khronos Blender glTF 2.0 I/O&#34;, version: &#34;2.0&#34;}
  cameras: []
  parser: GLTFParser {json: {…}, extensions: {…}, options: {…}, cache: {…}, primitiveCache: {…}, …}
  scene: Scene {uuid: &#34;1CF93318-696B-4411-B672-4C12C46DF7E1&#34;, name: &#34;Scene&#34;, type: &#34;Scene&#34;, parent: null, children: Array(0), …}
  scenes: [Scene]
  userData: {}
  __proto__: Object
}
</code>
  </pre>
</section>

<ul>
<li><strong><code>gltfData.animations</code></strong> is an array of animation clips. Here, there&rsquo;s a flying animation. We&rsquo;ll make use of this <a href="/book/first-steps/animation-system/">in the next chapter</a>.</li>
<li><strong><code>gltfData.assets</code></strong> contains metadata showing this glTF file was created using the <a href="https://www.blender.org/" target="_blank" rel="noopener noreferrer">Blender</a> exporter.</li>
<li><strong><code>gltfData.cameras</code></strong> is an array of cameras. This file doesn&rsquo;t contain any cameras, so the array is empty.</li>
<li><strong><code>gltfData.parser</code></strong> contains technical details about the <code>GLTFLoader</code>.</li>
<li><strong><code>gltfData.scene</code></strong> is a <a href="/book/first-steps/organizing-with-group/#hello-group"><code>Group</code></a> containing any meshes from the file. <strong>This is where we&rsquo;ll find the parrot model.</strong></li>
<li><strong><code>gltfData.scenes</code></strong>: The glTF format supports storing multiple scenes in a single file. In practice, this feature is rarely used.</li>
<li><strong><code>gltfData.userData</code></strong> may contain additional non-standard data.</li>
</ul>
<p><em><code>__proto__</code> is a standard property that every JavaScript object has, you can ignore that.</em></p>
<p>Usually, all you need is <strong><code>.animations</code></strong>, <strong><code>.cameras</code></strong>, and <strong><code>.scene</code></strong> (not <code>.scenes</code>!) and you can safely ignore everything else.</p>
<h2 id="process-the-loaded-data">Process the Loaded Data</h2>
<p>Extracting data from a glTF file usually follows a predictable pattern, especially if the file contains a single animated model, as these three files do. This means we can create a <code>setupModel</code> function and then run it on each of the three files. We&rsquo;ll do this in a separate module. Open or create the <em><strong>birds/setupModel.js</strong></em> module, and create the function, following the now-familiar pattern:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>birds/setupModel.js</strong></em>: initial structure</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
function setupModel(data) {}

export { setupModel };
</code>
  </pre>
</section>

<p>The idea of this function is that we can pass in the loaded data and get back the bird model, ready to be added to the scene. Next, import this new module into <em><strong>birds.js</strong></em>, then pass in the loaded data. Finally, return the results for use within World.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>birds.js</strong></em>: process loaded data</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line="3,12,14"
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
import { GLTFLoader } from &#39;three/examples/jsm/loaders/GLTFLoader.js&#39;;

import { setupModel } from &#39;./setupModel.js&#39;;

async function loadBirds() {
  const loader = new GLTFLoader();

  const parrotData = await loader.loadAsync(&#39;/assets/models/Parrot.glb&#39;);

  console.log(&#39;Squaaawk!&#39;, parrotData);

  const parrot = setupModel(parrotData);

  return { parrot }
}
</code>
  </pre>
</section>

<h3 id="extract-the-mesh-from-the-loaded-data">Extract the Mesh from the Loaded Data</h3>
<p>At this point, we have the unprocessed loaded data within the <code>setupModel</code> function. The next step is to extract the model, and then do any processing to prepare it for use. The amount of work we need to do here depends on the model, and what we want to do with it. Here, all we need to do is extract the mesh, but in the next chapter, we&rsquo;ll have a bit more work to do as we connect the animation clip to the mesh.</p>
<p>Look at the loaded data in the console again, and expand the <code>gltfData.scene</code>. This a <a href="/book/first-steps/organizing-with-group/#hello-group"><code>Group</code></a>, and any meshes that are in the file will be <a href="/book/first-steps/transformations/#the-scene-graph">children of the group</a>. These can be accessed using the <a href="/book/first-steps/transformations/#accessing-a-scene-objects-children"><code>group.children</code></a> array. If you look inside there, you&rsquo;ll see that <code>glTF.scene.children</code> has only one object inside it, so that must be our parrot model.</p>
<p>Using this knowledge, we can finish the <code>setupModel</code> function:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>setupModel.js</strong></em>: extract the model from the loaded data</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line="2,4"
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">function setupModel(data) {
  const model = data.scene.children[0];

  return model;
}
</code>
  </pre>
</section>

<p><em>Note A: if you click the toggle to complete the scene in the editor, then view the <code>gltfData.scene.children</code> array in the console, it will be empty. This is because, by the time you look at it, the mesh has already been removed and added to the scene.</em></p>
<p><em>Note B: you could also just add the <code>gltf.scene</code> to your scene since it&rsquo;s a group. That would add an additional node to your scene graph but everything will still work. However, it&rsquo;s best practice to keep your scene graph as simple as possible, since every node means additional calculations are required to render the scene.</em></p>
<h3 id="add-the-mesh-to-the-scene">Add the Mesh to the Scene</h3>
<p>Over in World, <code>loadBirds</code> now returns the parrot mesh and you can add it to the scene:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: add the mesh to the scene</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="34"
    data-line="35,37"
    data-line-offset="34"
    >
    <code class="highlight language-js match-braces">
  async init() {
    const { parrot } = await loadBirds();

    scene.add(parrot);
  }
</code>
  </pre>
</section>

<h2 id="load-the-other-two-birds">Load the Other Two Birds</h2>
<p>You can use a single instance of the <code>GLTFLoader</code> to load any number of files. When performing multiple asynchronous operations with async functions, you should (in most cases) use <code>Promise.all</code>. We go into the reason for this in more detail <a href="/book/appendix/asynchronous-javascript/#loading-multiple-files-with-async-functions-first-attempt">in the appendix</a>, but here&rsquo;s the short version.</p>
<p>First, here&rsquo;s the obvious way of loading the other two files:</p>


<section class="highlight-wrapper"><span class="caption">Load multiple glTF files, the WRONG way</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
// Don&#39;t do this!
const parrotData = await loader.loadAsync(&#39;/assets/models/Parrot.glb&#39;);
const flamingoData = await loader.loadAsync(&#39;/assets/models/Flamingo.glb&#39;);
const storkData = await loader.loadAsync(&#39;/assets/models/Stork.glb&#39;);

const parrot = setupModel(parrotData);
const flamingo = setupModel(flamingoData);
const stork = setupModel(storkData);
</code>
  </pre>
</section>

<p>There&rsquo;s a problem with this approach. <a href="#set-up-main-js-and-world-js-to-handle-async-await">As we stated above</a>, <code>await</code> means <em>wait here until the file has loaded</em>. This means the app will wait until the parrot has fully loaded, <em>then</em> start to load the flamingo, wait until <em>that</em> has fully loaded, and <em>finally</em> start to load the stork. Using this approach, loading will take nearly three times longer than it should.</p>
<p>Instead, we want all three files to load at the same time, and the simplest way of doing this is to use <code>Promise.all</code>.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>birds.js</strong></em>: load the other two file using <code>Promise.all</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="8"
    data-line=""
    data-line-offset="8"
    >
    <code class="highlight language-js match-braces">

const [parrotData, flamingoData, storkData] = await Promise.all([
  loader.loadAsync(&#39;/assets/models/Parrot.glb&#39;),
  loader.loadAsync(&#39;/assets/models/Flamingo.glb&#39;),
  loader.loadAsync(&#39;/assets/models/Stork.glb&#39;),
]);

</code>
  </pre>
</section>

<p>Then we can process each file&rsquo;s loaded data using the <code>setupModel</code> function. Once we do that, here&rsquo;s our (nearly complete) <code>loadModels</code> function:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>birds.js</strong></em>: load and then process multiple glTF files</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="5"
    data-line="8-12,17-18,22,23"
    data-line-offset="5"
    >
    <code class="highlight language-js match-braces">
async function loadBirds() {
  const loader = new GLTFLoader();

  const [parrotData, flamingoData, storkData] = await Promise.all([
    loader.loadAsync(&#39;/assets/models/Parrot.glb&#39;),
    loader.loadAsync(&#39;/assets/models/Flamingo.glb&#39;),
    loader.loadAsync(&#39;/assets/models/Stork.glb&#39;),
  ]);

  console.log(&#39;Squaaawk!&#39;, parrotData);

  const parrot = setupModel(parrotData);
  const flamingo = setupModel(flamingoData);
  const stork = setupModel(storkData);

  return {
    parrot,
    flamingo,
    stork,
  };
}
</code>
  </pre>
</section>

<p>Over in World, you now have all three models. Add them to your scene:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: add the second two birds to the scene</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="36"
    data-line=""
    data-line-offset="36"
    >
    <code class="highlight language-js match-braces">
async init() {
  const { parrot, flamingo, stork } = await loadBirds();

  scene.add(parrot, flamingo, stork);
}
</code>
  </pre>
</section>

<p>Great! Well&hellip;</p>







<figure id="scene-412957638" class="inline-scene loading-dots "></figure>

<script type="module">
  import init from "/static/examples/worlds/inline-scenes/first-steps/birds-jumbled.js";
  init("#scene-412957638");
</script>

<p>Just like visiting the zoo!</p>
<h3 id="move-the-birds-into-position">Move the Birds into Position</h3>
<p>It is possible for models loaded from a glTF file to have a position already specified, but that&rsquo;s not the case here, so all three models start at the point $(0,0,0)$, all jumbled together on top of each other. We&rsquo;ll adjust the position of each bird to make it look like they are flying in formation:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>birds.js</strong></em>: move the birds into position</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="16"
    data-line="17,20,23"
    data-line-offset="16"
    >
    <code class="highlight language-js match-braces">  const parrot = setupModel(parrotData);
  parrot.position.set(0, 0, 2.5);

  const flamingo = setupModel(flamingoData);
  flamingo.position.set(7.5, 0, -10);

  const stork = setupModel(storkData);
  stork.position.set(0, -2.5, -10);
</code>
  </pre>
</section>

<h3 id="final-_birdsjs_-module">Final <em><strong>birds.js</strong></em> Module</h3>
<p>The <em><strong>birds.js</strong></em> module is now complete. Here&rsquo;s the final code:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>birds.js</strong></em>: final code</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">import { GLTFLoader } from &#39;three/examples/jsm/loaders/GLTFLoader.js&#39;;

import { setupModel } from &#39;./setupModel.js&#39;;

async function loadBirds() {
  const loader = new GLTFLoader();

  const [parrotData, flamingoData, storkData] = await Promise.all([
    loader.loadAsync(&#39;/assets/models/Parrot.glb&#39;),
    loader.loadAsync(&#39;/assets/models/Flamingo.glb&#39;),
    loader.loadAsync(&#39;/assets/models/Stork.glb&#39;),
  ]);

  console.log(&#39;Squaaawk!&#39;, parrotData);

  const parrot = setupModel(parrotData);
  parrot.position.set(0, 0, 2.5);

  const flamingo = setupModel(flamingoData);
  flamingo.position.set(7.5, 0, -10);

  const stork = setupModel(storkData);
  stork.position.set(0, -2.5, -10);

  return {
    parrot,
    flamingo,
    stork,
  };
}

export { loadBirds };
</code>
  </pre>
</section>

<h3 id="center-the-camera-on-the-parrot">Center the Camera on the Parrot</h3>
<p>The very last thing we&rsquo;ll do is <a href="/book/first-steps/camera-controls/#manually-set-the-target">adjust the <code>OrbitControls</code> target</a>. Currently, this is in its default position, the center of the scene. Now that we have moved the birds into formation, this ends up being somewhere around the tail of the parrot. It would look better if the camera focused on the center of the bird rather than its tail. We can easily set this up by copying the <code>parrot.position</code> into <code>controls.target</code>. However, to do so, we need to access <code>controls</code> within <code>.init</code>, so first, let&rsquo;s convert it to a module-scoped variable.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: make <code>controls</code> a module scoped variable</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="11"
    data-line="12"
    data-line-offset="11"
    >
    <code class="highlight language-js match-braces">let camera;
let controls;
let renderer;
let scene;
let loop;
</code>
  </pre>
</section>



<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: make <code>controls</code> a module scoped variable</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="18"
    data-line="24"
    data-line-offset="18"
    >
    <code class="highlight language-js match-braces">  constructor(container) {
    camera = createCamera();
    renderer = createRenderer();
    scene = createScene();
    loop = new Loop(camera, scene, renderer);
    container.append(renderer.domElement);
    controls = createControls(camera, renderer.domElement);

    const { ambientLight, mainLight } = createLights();

    loop.updatables.push(controls);
    scene.add(ambientLight, mainLight);

    const resizer = new Resizer(container, camera, renderer);
  }
</code>
  </pre>
</section>

<p>Now, the controls are accessible from <code>.init</code> and we can move the target to the center of the parrot.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: target the parrot with the camera</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="34"
    data-line="38"
    data-line-offset="34"
    >
    <code class="highlight language-js match-braces">  async init() {
    const { parrot, flamingo, stork } = await loadBirds();

    // move the target to the center of the front bird
    controls.target.copy(parrot.position);

    scene.add(parrot, flamingo, stork);
  }
</code>
  </pre>
</section>








<figure id="scene-937254618" class="inline-scene loading-dots "></figure>

<script type="module">
  import init from "/static/examples/worlds/inline-scenes/first-steps/birds-still.js";
  init("#scene-937254618");
</script>

<p>Next up, we&rsquo;ll introduce the three.js animation system and show you how to play the animation clips that were loaded alongside the bird models.</p>
<h2 id="challenges">Challenges</h2>
<aside class="success">
  
    <h3 id="easy">Easy</h3>
<ol>
<li>
<p>Look at that parrot hogging the limelight! Switch around the bird&rsquo;s positions to give the stork and the flamingo each a turn in leading the flock.</p>
</li>
<li>
<p>Alternatively, leave the birds in place and try making the <code>controls.target</code> focus on one of the other two birds instead of the parrot.</p>
</li>
</ol>

  
</aside>
<aside class="notice">
  
    <h3 id="medium">Medium</h3>
<ol>
<li>Add a <code>&lt;button&gt;</code> element with the text <em>Switch Focus</em>. Whenever you click this button, the camera should focus on the next bird. You can implement this however you like, but, if you want to do it in keeping with our work so far, you should set up the buttons inside <em><strong>main.js</strong></em> and then <a href="/book/first-steps/world-app/#the-world-interface">expand the World class interface</a> with a method to move focus onto the next bird. You can call this method <code>World.focusNext</code> or something similar.</li>
</ol>

  
</aside>
<aside class="warning">
  
    <h3 id="hard">Hard</h3>
<ol>
<li>
<p>Once you have implemented the button above, you&rsquo;ll have three camera views, one for each bird. Add a fourth view which is a zoomed-out overview of the scene that allows you to see all three birds. For this fourth view, you may need to adjust the <code>camera.position</code> as well as the <code>controls.target</code>.</p>
</li>
<li>
<p>Now, make the camera smoothly animate from one viewpoint to the next. You will have to animate the camera.position and the controls.target at the same time. The best place to do this is within the <code>controls.tick</code> method.</p>
</li>
</ol>

  
</aside>
